{"/home/travis/build/npmtest/node-npmtest-flatpickr/test.js":"/* istanbul instrument in package npmtest_flatpickr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-flatpickr/lib.npmtest_flatpickr.js":"/* istanbul instrument in package npmtest_flatpickr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_flatpickr = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_flatpickr = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-flatpickr/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-flatpickr && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_flatpickr */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_flatpickr\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_flatpickr.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_flatpickr.rollup.js'] =\n            local.assetsDict['/assets.npmtest_flatpickr.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_flatpickr.__dirname + '/lib.npmtest_flatpickr.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-flatpickr/node_modules/flatpickr/dist/flatpickr.js":"var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! flatpickr v2.5.7, @license MIT */\nfunction Flatpickr(element, config) {\n\tvar self = this;\n\n\tself._ = {};\n\tself._.afterDayAnim = afterDayAnim;\n\tself.changeMonth = changeMonth;\n\tself.changeYear = changeYear;\n\tself.clear = clear;\n\tself.close = close;\n\tself._createElement = createElement;\n\tself.destroy = destroy;\n\tself.isEnabled = isEnabled;\n\tself.jumpToDate = jumpToDate;\n\tself.open = open;\n\tself.redraw = redraw;\n\tself.set = set;\n\tself.setDate = setDate;\n\tself.toggle = toggle;\n\n\tfunction init() {\n\t\tif (element._flatpickr) element._flatpickr = undefined;\n\n\t\telement._flatpickr = self;\n\n\t\tself.element = element;\n\t\tself.instanceConfig = config || {};\n\t\tself.parseDate = Flatpickr.prototype.parseDate.bind(self);\n\t\tself.formatDate = Flatpickr.prototype.formatDate.bind(self);\n\n\t\tsetupFormats();\n\t\tparseConfig();\n\t\tsetupLocale();\n\t\tsetupInputs();\n\t\tsetupDates();\n\t\tsetupHelperFunctions();\n\n\t\tself.isOpen = false;\n\n\t\tself.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === \"single\" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n\t\tif (!self.isMobile) build();\n\n\t\tbindEvents();\n\n\t\tif (self.selectedDates.length || self.config.noCalendar) {\n\t\t\tif (self.config.enableTime) {\n\t\t\t\tsetHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : null);\n\t\t\t}\n\t\t\tupdateValue();\n\t\t}\n\n\t\tif (self.config.weekNumbers) {\n\t\t\tself.calendarContainer.style.width = self.daysContainer.clientWidth + self.weekWrapper.clientWidth + \"px\";\n\t\t}\n\n\t\tself.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;\n\n\t\tif (!self.isMobile) positionCalendar();\n\n\t\ttriggerEvent(\"Ready\");\n\t}\n\n\t/**\n  * Binds a function to the current flatpickr instance\n  * @param {Function} fn the function\n  * @return {Function} the function bound to the instance\n  */\n\tfunction bindToInstance(fn) {\n\t\treturn fn.bind(self);\n\t}\n\n\t/**\n  * The handler for all events targeting the time inputs\n  * @param {Event} e the event - \"input\", \"wheel\", \"increment\", etc\n  */\n\tfunction updateTime(e) {\n\t\tif (self.config.noCalendar && !self.selectedDates.length)\n\t\t\t// picking time only\n\t\t\tself.selectedDates = [self.now];\n\n\t\ttimeWrapper(e);\n\n\t\tif (!self.selectedDates.length) return;\n\n\t\tif (!self.minDateHasTime || e.type !== \"input\" || e.target.value.length >= 2) {\n\t\t\tsetHoursFromInputs();\n\t\t\tupdateValue();\n\t\t} else {\n\t\t\tsetTimeout(function () {\n\t\t\t\tsetHoursFromInputs();\n\t\t\t\tupdateValue();\n\t\t\t}, 1000);\n\t\t}\n\t}\n\n\t/**\n  * Syncs the selected date object time with user's time input\n  */\n\tfunction setHoursFromInputs() {\n\t\tif (!self.config.enableTime) return;\n\n\t\tvar hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),\n\t\t    minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,\n\t\t    seconds = self.config.enableSeconds ? parseInt(self.secondElement.value, 10) || 0 : 0;\n\n\t\tif (self.amPM) hours = hours % 12 + 12 * (self.amPM.textContent === \"PM\");\n\n\t\tif (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {\n\n\t\t\thours = Math.max(hours, self.config.minDate.getHours());\n\t\t\tif (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());\n\t\t}\n\n\t\tif (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {\n\t\t\thours = Math.min(hours, self.config.maxDate.getHours());\n\t\t\tif (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());\n\t\t}\n\n\t\tsetHours(hours, minutes, seconds);\n\t}\n\n\t/**\n  * Syncs time input values with a date\n  * @param {Date} dateObj the date to sync with\n  */\n\tfunction setHoursFromDate(dateObj) {\n\t\tvar date = dateObj || self.latestSelectedDateObj;\n\n\t\tif (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());\n\t}\n\n\t/**\n  * Sets the hours, minutes, and optionally seconds\n  * of the latest selected date object and the\n  * corresponding time inputs\n  * @param {Number} hours the hour. whether its military\n  *                 or am-pm gets inferred from config\n  * @param {Number} minutes the minutes\n  * @param {Number} seconds the seconds (optional)\n  */\n\tfunction setHours(hours, minutes, seconds) {\n\t\tif (self.selectedDates.length) {\n\t\t\tself.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);\n\t\t}\n\n\t\tif (!self.config.enableTime || self.isMobile) return;\n\n\t\tself.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);\n\n\t\tself.minuteElement.value = self.pad(minutes);\n\n\t\tif (!self.config.time_24hr) self.amPM.textContent = hours >= 12 ? \"PM\" : \"AM\";\n\n\t\tif (self.config.enableSeconds === true) self.secondElement.value = self.pad(seconds);\n\t}\n\n\t/**\n  * Handles the year input and incrementing events\n  * @param {Event} event the keyup or increment event\n  */\n\tfunction onYearInput(event) {\n\t\tvar year = event.target.value;\n\t\tif (event.delta) year = (parseInt(year) + event.delta).toString();\n\n\t\tif (year.length === 4 || event.key === \"Enter\") {\n\t\t\tself.currentYearElement.blur();\n\t\t\tif (!/[^\\d]/.test(year)) changeYear(year);\n\t\t}\n\t}\n\n\t/**\n  * Essentially addEventListener + tracking\n  * @param {Element} element the element to addEventListener to\n  * @param {String} event the event name\n  * @param {Function} handler the event handler\n  */\n\tfunction bind(element, event, handler) {\n\t\tif (event instanceof Array) return event.forEach(function (ev) {\n\t\t\treturn bind(element, ev, handler);\n\t\t});\n\n\t\telement.addEventListener(event, handler);\n\t\tself._handlers.push({ element: element, event: event, handler: handler });\n\t}\n\n\t/**\n  * A mousedown handler which mimics click.\n  * Minimizes latency, since we don't need to wait for mouseup in most cases.\n  * Also, avoids handling right clicks.\n  *\n  * @param {Function} handler the event handler\n  */\n\tfunction onClick(handler) {\n\t\treturn function (evt) {\n\t\t\treturn evt.which === 1 && handler(evt);\n\t\t};\n\t}\n\n\t/**\n  * Adds all the necessary event listeners\n  */\n\tfunction bindEvents() {\n\t\tself._handlers = [];\n\t\tif (self.config.wrap) {\n\t\t\t[\"open\", \"close\", \"toggle\", \"clear\"].forEach(function (evt) {\n\t\t\t\tArray.prototype.forEach.call(self.element.querySelectorAll(\"[data-\" + evt + \"]\"), function (el) {\n\t\t\t\t\treturn bind(el, \"mousedown\", onClick(self[evt]));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tif (self.isMobile) return setupMobile();\n\n\t\tself.debouncedResize = debounce(onResize, 50);\n\t\tself.triggerChange = function () {\n\t\t\ttriggerEvent(\"Change\");\n\t\t};\n\t\tself.debouncedChange = debounce(self.triggerChange, 300);\n\n\t\tif (self.config.mode === \"range\" && self.daysContainer) bind(self.daysContainer, \"mouseover\", function (e) {\n\t\t\treturn onMouseOver(e.target);\n\t\t});\n\n\t\tbind(window.document.body, \"keydown\", onKeyDown);\n\n\t\tif (!self.config.static) bind(self._input, \"keydown\", onKeyDown);\n\n\t\tif (!self.config.inline && !self.config.static) bind(window, \"resize\", self.debouncedResize);\n\n\t\tif (window.ontouchstart) bind(window.document, \"touchstart\", documentClick);\n\n\t\tbind(window.document, \"mousedown\", onClick(documentClick));\n\t\tbind(self._input, \"blur\", documentClick);\n\n\t\tif (self.config.clickOpens) bind(self._input, \"focus\", open);\n\n\t\tif (!self.config.noCalendar) {\n\t\t\tbind(self.prevMonthNav, \"mousedown\", onClick(function () {\n\t\t\t\treturn changeMonth(-1);\n\t\t\t}));\n\t\t\tbind(self.nextMonthNav, \"mousedown\", onClick(function () {\n\t\t\t\treturn changeMonth(1);\n\t\t\t}));\n\n\t\t\tself.monthNav.addEventListener(\"wheel\", function (e) {\n\t\t\t\treturn e.preventDefault();\n\t\t\t});\n\n\t\t\tbind(self.monthNav, \"wheel\", debounce(onMonthNavScroll, 10));\n\t\t\tbind(self.monthNav, \"mousedown\", onClick(onMonthNavClick));\n\n\t\t\tbind(self.monthNav, \"mousedown\", onClick(function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\tif (e.target === self.currentYearElement) self.currentYearElement.select();\n\t\t\t}));\n\n\t\t\tbind(self.monthNav, [\"keyup\", \"increment\"], onYearInput);\n\n\t\t\tbind(self.daysContainer, \"mousedown\", onClick(selectDate));\n\n\t\t\tif (self.config.animate) {\n\t\t\t\tbind(self.daysContainer, [\"webkitAnimationEnd\", \"animationend\"], animateDays);\n\t\t\t\tbind(self.monthNav, [\"webkitAnimationEnd\", \"animationend\"], animateMonths);\n\t\t\t}\n\t\t}\n\n\t\tif (self.config.enableTime) {\n\t\t\tbind(self.timeContainer, [\"wheel\", \"input\", \"increment\"], updateTime);\n\t\t\tbind(self.timeContainer, \"mousedown\", onClick(timeIncrement));\n\n\t\t\tbind(self.timeContainer, [\"wheel\", \"increment\"], self.debouncedChange);\n\t\t\tbind(self.timeContainer, \"input\", self.triggerChange);\n\n\t\t\tbind(self.hourElement, \"focus\", function () {\n\t\t\t\treturn self.hourElement.select();\n\t\t\t});\n\t\t\tbind(self.minuteElement, \"focus\", function () {\n\t\t\t\treturn self.minuteElement.select();\n\t\t\t});\n\n\t\t\tif (self.secondElement) bind(self.secondElement, \"focus\", function () {\n\t\t\t\treturn self.secondElement.select();\n\t\t\t});\n\n\t\t\tif (self.amPM) {\n\t\t\t\tbind(self.amPM, \"mousedown\", onClick(function (e) {\n\t\t\t\t\tupdateTime(e);\n\t\t\t\t\tself.triggerChange(e);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Removes the day container that slided out of view\n  * @param {Event} e the animation event\n  */\n\tfunction animateDays(e) {\n\t\tif (self.daysContainer.childNodes.length > 1) {\n\t\t\tswitch (e.animationName) {\n\t\t\t\tcase \"slideLeft\":\n\t\t\t\t\tself.daysContainer.lastChild.classList.remove(\"slideLeftNew\");\n\t\t\t\t\tself.daysContainer.removeChild(self.daysContainer.firstChild);\n\t\t\t\t\tself.days = self.daysContainer.firstChild;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"slideRight\":\n\t\t\t\t\tself.daysContainer.firstChild.classList.remove(\"slideRightNew\");\n\t\t\t\t\tself.daysContainer.removeChild(self.daysContainer.lastChild);\n\t\t\t\t\tself.days = self.daysContainer.firstChild;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Removes the month element that animated out of view\n  * @param {Event} e the animation event\n  */\n\tfunction animateMonths(e) {\n\t\tswitch (e.animationName) {\n\t\t\tcase \"slideLeftNew\":\n\t\t\tcase \"slideRightNew\":\n\t\t\t\tself.navigationCurrentMonth.classList.remove(\"slideLeftNew\");\n\t\t\t\tself.navigationCurrentMonth.classList.remove(\"slideRightNew\");\n\t\t\t\tvar nav = self.navigationCurrentMonth;\n\n\t\t\t\twhile (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {\n\t\t\t\t\tself.monthNav.removeChild(nav.nextSibling);\n\t\t\t\t}while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {\n\t\t\t\t\tself.monthNav.removeChild(nav.previousSibling);\n\t\t\t\t}self.oldCurMonth = null;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n  * Set the calendar view to a particular date.\n  * @param {Date} jumpDate the date to set the view to\n  */\n\tfunction jumpToDate(jumpDate) {\n\t\tjumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);\n\n\t\ttry {\n\t\t\tself.currentYear = jumpDate.getFullYear();\n\t\t\tself.currentMonth = jumpDate.getMonth();\n\t\t} catch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e.stack);\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.warn(\"Invalid date supplied: \" + jumpDate);\n\t\t}\n\n\t\tself.redraw();\n\t}\n\n\t/**\n  * The up/down arrow handler for time inputs\n  * @param {Event} e the click event\n  */\n\tfunction timeIncrement(e) {\n\t\tif (~e.target.className.indexOf(\"arrow\")) incrementNumInput(e, e.target.classList.contains(\"arrowUp\") ? 1 : -1);\n\t}\n\n\t/**\n  * Increments/decrements the value of input associ-\n  * ated with the up/down arrow by dispatching an\n  * \"increment\" event on the input.\n  *\n  * @param {Event} e the click event\n  * @param {Number} delta the diff (usually 1 or -1)\n  * @param {Element} inputElem the input element\n  */\n\tfunction incrementNumInput(e, delta, inputElem) {\n\t\tvar input = inputElem || e.target.parentNode.childNodes[0];\n\t\tvar event = createEvent(\"increment\");\n\t\tevent.delta = delta;\n\t\tinput.dispatchEvent(event);\n\t}\n\n\tfunction createNumberInput(inputClassName) {\n\t\tvar wrapper = createElement(\"div\", \"numInputWrapper\"),\n\t\t    numInput = createElement(\"input\", \"numInput \" + inputClassName),\n\t\t    arrowUp = createElement(\"span\", \"arrowUp\"),\n\t\t    arrowDown = createElement(\"span\", \"arrowDown\");\n\n\t\tnumInput.type = \"text\";\n\t\tnumInput.pattern = \"\\\\d*\";\n\n\t\twrapper.appendChild(numInput);\n\t\twrapper.appendChild(arrowUp);\n\t\twrapper.appendChild(arrowDown);\n\n\t\treturn wrapper;\n\t}\n\n\tfunction build() {\n\t\tvar fragment = window.document.createDocumentFragment();\n\t\tself.calendarContainer = createElement(\"div\", \"flatpickr-calendar\");\n\t\tself.calendarContainer.tabIndex = -1;\n\n\t\tif (!self.config.noCalendar) {\n\t\t\tfragment.appendChild(buildMonthNav());\n\t\t\tself.innerContainer = createElement(\"div\", \"flatpickr-innerContainer\");\n\n\t\t\tif (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());\n\n\t\t\tself.rContainer = createElement(\"div\", \"flatpickr-rContainer\");\n\t\t\tself.rContainer.appendChild(buildWeekdays());\n\n\t\t\tif (!self.daysContainer) {\n\t\t\t\tself.daysContainer = createElement(\"div\", \"flatpickr-days\");\n\t\t\t\tself.daysContainer.tabIndex = -1;\n\t\t\t}\n\n\t\t\tbuildDays();\n\t\t\tself.rContainer.appendChild(self.daysContainer);\n\n\t\t\tself.innerContainer.appendChild(self.rContainer);\n\t\t\tfragment.appendChild(self.innerContainer);\n\t\t}\n\n\t\tif (self.config.enableTime) fragment.appendChild(buildTime());\n\n\t\ttoggleClass(self.calendarContainer, \"rangeMode\", self.config.mode === \"range\");\n\t\ttoggleClass(self.calendarContainer, \"animate\", self.config.animate);\n\n\t\tself.calendarContainer.appendChild(fragment);\n\n\t\tvar customAppend = self.config.appendTo && self.config.appendTo.nodeType;\n\n\t\tif (self.config.inline || self.config.static) {\n\t\t\tself.calendarContainer.classList.add(self.config.inline ? \"inline\" : \"static\");\n\n\t\t\tif (self.config.inline && !customAppend) {\n\t\t\t\treturn self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);\n\t\t\t}\n\n\t\t\tif (self.config.static) {\n\t\t\t\tvar wrapper = createElement(\"div\", \"flatpickr-wrapper\");\n\t\t\t\tself.element.parentNode.insertBefore(wrapper, self.element);\n\t\t\t\twrapper.appendChild(self.element);\n\n\t\t\t\tif (self.altInput) wrapper.appendChild(self.altInput);\n\n\t\t\t\twrapper.appendChild(self.calendarContainer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t(customAppend ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);\n\t}\n\n\tfunction createDay(className, date, dayNumber, i) {\n\t\tvar dateIsEnabled = isEnabled(date, true),\n\t\t    dayElement = createElement(\"span\", \"flatpickr-day \" + className, date.getDate());\n\n\t\tdayElement.dateObj = date;\n\t\tdayElement.$i = i;\n\t\tdayElement.setAttribute(\"aria-label\", self.formatDate(date, \"F j, Y\"));\n\n\t\tif (compareDates(date, self.now) === 0) {\n\t\t\tself.todayDateElem = dayElement;\n\t\t\tdayElement.classList.add(\"today\");\n\t\t}\n\n\t\tif (dateIsEnabled) {\n\t\t\tdayElement.tabIndex = -1;\n\t\t\tif (isDateSelected(date)) {\n\t\t\t\tdayElement.classList.add(\"selected\");\n\t\t\t\tself.selectedDateElem = dayElement;\n\t\t\t\tif (self.config.mode === \"range\") {\n\t\t\t\t\ttoggleClass(dayElement, \"startRange\", compareDates(date, self.selectedDates[0]) === 0);\n\n\t\t\t\t\ttoggleClass(dayElement, \"endRange\", compareDates(date, self.selectedDates[1]) === 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdayElement.classList.add(\"disabled\");\n\t\t\tif (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;\n\t\t}\n\n\t\tif (self.config.mode === \"range\") {\n\t\t\tif (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add(\"inRange\");\n\n\t\t\tif (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add(\"notAllowed\");\n\t\t}\n\n\t\tif (self.config.weekNumbers && className !== \"prevMonthDay\" && dayNumber % 7 === 1) {\n\t\t\tself.weekNumbers.insertAdjacentHTML(\"beforeend\", \"<span class='disabled flatpickr-day'>\" + self.config.getWeek(date) + \"</span>\");\n\t\t}\n\n\t\ttriggerEvent(\"DayCreate\", dayElement);\n\n\t\treturn dayElement;\n\t}\n\n\tfunction focusOnDay(currentIndex, offset) {\n\t\tvar newIndex = currentIndex + offset || 0,\n\t\t    targetNode = currentIndex !== undefined ? self.days.childNodes[newIndex] : self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],\n\t\t    focus = function focus() {\n\t\t\ttargetNode = targetNode || self.days.childNodes[newIndex];\n\t\t\ttargetNode.focus();\n\n\t\t\tif (self.config.mode === \"range\") onMouseOver(targetNode);\n\t\t};\n\n\t\tif (targetNode === undefined && offset !== 0) {\n\t\t\tif (offset > 0) {\n\t\t\t\tself.changeMonth(1);\n\t\t\t\tnewIndex = newIndex % 42;\n\t\t\t} else if (offset < 0) {\n\t\t\t\tself.changeMonth(-1);\n\t\t\t\tnewIndex += 42;\n\t\t\t}\n\n\t\t\treturn afterDayAnim(focus);\n\t\t}\n\n\t\tfocus();\n\t}\n\n\tfunction afterDayAnim(fn) {\n\t\tif (self.config.animate) return setTimeout(fn, self._.daysAnimDuration + 1);\n\t\tfn();\n\t}\n\n\tfunction buildDays(delta) {\n\t\tvar firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7,\n\t\t    isRangeMode = self.config.mode === \"range\";\n\n\t\tself.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);\n\t\tself.selectedDateElem = undefined;\n\t\tself.todayDateElem = undefined;\n\n\t\tvar daysInMonth = self.utils.getDaysinMonth(),\n\t\t    days = window.document.createDocumentFragment();\n\n\t\tvar dayNumber = self.prevMonthDays + 1 - firstOfMonth,\n\t\t    dayIndex = 0;\n\n\t\tif (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = \"\";\n\n\t\tif (isRangeMode) {\n\t\t\t// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;\n\t\t\tself.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);\n\t\t\tself.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - firstOfMonth) % daysInMonth);\n\t\t}\n\n\t\t// prepend days from the ending of previous month\n\t\tfor (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {\n\t\t\tdays.appendChild(createDay(\"prevMonthDay\", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber, dayIndex));\n\t\t}\n\n\t\t// Start at 1 since there is no 0th day\n\t\tfor (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {\n\t\t\tdays.appendChild(createDay(\"\", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber, dayIndex));\n\t\t}\n\n\t\t// append days from the next month\n\t\tfor (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {\n\t\t\tdays.appendChild(createDay(\"nextMonthDay\", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum, dayIndex));\n\t\t}\n\n\t\tif (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {\n\t\t\tself._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > days.childNodes[0].dateObj;\n\n\t\t\tself._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n\t\t} else updateNavigationCurrentMonth();\n\n\t\tvar dayContainer = createElement(\"div\", \"dayContainer\");\n\t\tdayContainer.appendChild(days);\n\n\t\tif (!self.config.animate || delta === undefined) clearNode(self.daysContainer);else {\n\t\t\twhile (self.daysContainer.childNodes.length > 1) {\n\t\t\t\tself.daysContainer.removeChild(self.daysContainer.firstChild);\n\t\t\t}\n\t\t}\n\n\t\tif (delta >= 0) self.daysContainer.appendChild(dayContainer);else self.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);\n\n\t\tself.days = self.daysContainer.firstChild;\n\t\treturn self.daysContainer;\n\t}\n\n\tfunction clearNode(node) {\n\t\twhile (node.firstChild) {\n\t\t\tnode.removeChild(node.firstChild);\n\t\t}\n\t}\n\n\tfunction buildMonthNav() {\n\t\tvar monthNavFragment = window.document.createDocumentFragment();\n\t\tself.monthNav = createElement(\"div\", \"flatpickr-month\");\n\n\t\tself.prevMonthNav = createElement(\"span\", \"flatpickr-prev-month\");\n\t\tself.prevMonthNav.innerHTML = self.config.prevArrow;\n\n\t\tself.currentMonthElement = createElement(\"span\", \"cur-month\");\n\t\tself.currentMonthElement.title = self.l10n.scrollTitle;\n\n\t\tvar yearInput = createNumberInput(\"cur-year\");\n\t\tself.currentYearElement = yearInput.childNodes[0];\n\t\tself.currentYearElement.title = self.l10n.scrollTitle;\n\n\t\tif (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();\n\n\t\tif (self.config.maxDate) {\n\t\t\tself.currentYearElement.max = self.config.maxDate.getFullYear();\n\n\t\t\tself.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();\n\t\t}\n\n\t\tself.nextMonthNav = createElement(\"span\", \"flatpickr-next-month\");\n\t\tself.nextMonthNav.innerHTML = self.config.nextArrow;\n\n\t\tself.navigationCurrentMonth = createElement(\"span\", \"flatpickr-current-month\");\n\t\tself.navigationCurrentMonth.appendChild(self.currentMonthElement);\n\t\tself.navigationCurrentMonth.appendChild(yearInput);\n\n\t\tmonthNavFragment.appendChild(self.prevMonthNav);\n\t\tmonthNavFragment.appendChild(self.navigationCurrentMonth);\n\t\tmonthNavFragment.appendChild(self.nextMonthNav);\n\t\tself.monthNav.appendChild(monthNavFragment);\n\n\t\tObject.defineProperty(self, \"_hidePrevMonthArrow\", {\n\t\t\tget: function get() {\n\t\t\t\treturn this.__hidePrevMonthArrow;\n\t\t\t},\n\t\t\tset: function set(bool) {\n\t\t\t\tif (this.__hidePrevMonthArrow !== bool) self.prevMonthNav.style.display = bool ? \"none\" : \"block\";\n\t\t\t\tthis.__hidePrevMonthArrow = bool;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(self, \"_hideNextMonthArrow\", {\n\t\t\tget: function get() {\n\t\t\t\treturn this.__hideNextMonthArrow;\n\t\t\t},\n\t\t\tset: function set(bool) {\n\t\t\t\tif (this.__hideNextMonthArrow !== bool) self.nextMonthNav.style.display = bool ? \"none\" : \"block\";\n\t\t\t\tthis.__hideNextMonthArrow = bool;\n\t\t\t}\n\t\t});\n\n\t\tupdateNavigationCurrentMonth();\n\n\t\treturn self.monthNav;\n\t}\n\n\tfunction buildTime() {\n\t\tself.calendarContainer.classList.add(\"hasTime\");\n\t\tif (self.config.noCalendar) self.calendarContainer.classList.add(\"noCalendar\");\n\t\tself.timeContainer = createElement(\"div\", \"flatpickr-time\");\n\t\tself.timeContainer.tabIndex = -1;\n\t\tvar separator = createElement(\"span\", \"flatpickr-time-separator\", \":\");\n\n\t\tvar hourInput = createNumberInput(\"flatpickr-hour\");\n\t\tself.hourElement = hourInput.childNodes[0];\n\n\t\tvar minuteInput = createNumberInput(\"flatpickr-minute\");\n\t\tself.minuteElement = minuteInput.childNodes[0];\n\n\t\tself.hourElement.tabIndex = self.minuteElement.tabIndex = -1;\n\n\t\tself.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour);\n\n\t\tself.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);\n\n\t\tself.hourElement.step = self.config.hourIncrement;\n\t\tself.minuteElement.step = self.config.minuteIncrement;\n\n\t\tself.hourElement.min = self.config.time_24hr ? 0 : 1;\n\t\tself.hourElement.max = self.config.time_24hr ? 23 : 12;\n\n\t\tself.minuteElement.min = 0;\n\t\tself.minuteElement.max = 59;\n\n\t\tself.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;\n\n\t\tself.timeContainer.appendChild(hourInput);\n\t\tself.timeContainer.appendChild(separator);\n\t\tself.timeContainer.appendChild(minuteInput);\n\n\t\tif (self.config.time_24hr) self.timeContainer.classList.add(\"time24hr\");\n\n\t\tif (self.config.enableSeconds) {\n\t\t\tself.timeContainer.classList.add(\"hasSeconds\");\n\n\t\t\tvar secondInput = createNumberInput(\"flatpickr-second\");\n\t\t\tself.secondElement = secondInput.childNodes[0];\n\n\t\t\tself.secondElement.value = self.latestSelectedDateObj ? self.pad(self.latestSelectedDateObj.getSeconds()) : \"00\";\n\n\t\t\tself.secondElement.step = self.minuteElement.step;\n\t\t\tself.secondElement.min = self.minuteElement.min;\n\t\t\tself.secondElement.max = self.minuteElement.max;\n\n\t\t\tself.timeContainer.appendChild(createElement(\"span\", \"flatpickr-time-separator\", \":\"));\n\t\t\tself.timeContainer.appendChild(secondInput);\n\t\t}\n\n\t\tif (!self.config.time_24hr) {\n\t\t\t// add self.amPM if appropriate\n\t\t\tself.amPM = createElement(\"span\", \"flatpickr-am-pm\", [\"AM\", \"PM\"][self.hourElement.value > 11 | 0]);\n\t\t\tself.amPM.title = self.l10n.toggleTitle;\n\t\t\tself.amPM.tabIndex = -1;\n\t\t\tself.timeContainer.appendChild(self.amPM);\n\t\t}\n\n\t\treturn self.timeContainer;\n\t}\n\n\tfunction buildWeekdays() {\n\t\tif (!self.weekdayContainer) self.weekdayContainer = createElement(\"div\", \"flatpickr-weekdays\");\n\n\t\tvar firstDayOfWeek = self.l10n.firstDayOfWeek;\n\t\tvar weekdays = self.l10n.weekdays.shorthand.slice();\n\n\t\tif (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {\n\t\t\tweekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));\n\t\t}\n\n\t\tself.weekdayContainer.innerHTML = \"\\n\\t\\t<span class=flatpickr-weekday>\\n\\t\\t\\t\" + weekdays.join(\"</span><span class=flatpickr-weekday>\") + \"\\n\\t\\t</span>\\n\\t\\t\";\n\n\t\treturn self.weekdayContainer;\n\t}\n\n\t/* istanbul ignore next */\n\tfunction buildWeeks() {\n\t\tself.calendarContainer.classList.add(\"hasWeeks\");\n\t\tself.weekWrapper = createElement(\"div\", \"flatpickr-weekwrapper\");\n\t\tself.weekWrapper.appendChild(createElement(\"span\", \"flatpickr-weekday\", self.l10n.weekAbbreviation));\n\t\tself.weekNumbers = createElement(\"div\", \"flatpickr-weeks\");\n\t\tself.weekWrapper.appendChild(self.weekNumbers);\n\n\t\treturn self.weekWrapper;\n\t}\n\n\tfunction changeMonth(value, is_offset, animate) {\n\t\tis_offset = is_offset === undefined || is_offset;\n\t\tvar delta = is_offset ? value : value - self.currentMonth;\n\t\tvar skipAnimations = !self.config.animate || animate === false;\n\n\t\tif (delta < 0 && self._hidePrevMonthArrow || delta > 0 && self._hideNextMonthArrow) return;\n\n\t\tself.currentMonth += delta;\n\n\t\tif (self.currentMonth < 0 || self.currentMonth > 11) {\n\t\t\tself.currentYear += self.currentMonth > 11 ? 1 : -1;\n\t\t\tself.currentMonth = (self.currentMonth + 12) % 12;\n\n\t\t\ttriggerEvent(\"YearChange\");\n\t\t}\n\n\t\tbuildDays(!skipAnimations ? delta : undefined);\n\n\t\tif (skipAnimations) {\n\t\t\ttriggerEvent(\"MonthChange\");\n\t\t\treturn updateNavigationCurrentMonth();\n\t\t}\n\n\t\t// remove possible remnants from clicking too fast\n\t\tvar nav = self.navigationCurrentMonth;\n\t\tif (delta < 0) {\n\t\t\twhile (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {\n\t\t\t\tself.monthNav.removeChild(nav.nextSibling);\n\t\t\t}\n\t\t} else if (delta > 0) {\n\t\t\twhile (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {\n\t\t\t\tself.monthNav.removeChild(nav.previousSibling);\n\t\t\t}\n\t\t}\n\n\t\tself.oldCurMonth = self.navigationCurrentMonth;\n\n\t\tself.navigationCurrentMonth = self.monthNav.insertBefore(self.oldCurMonth.cloneNode(true), delta > 0 ? self.oldCurMonth.nextSibling : self.oldCurMonth);\n\n\t\tif (delta > 0) {\n\t\t\tself.daysContainer.firstChild.classList.add(\"slideLeft\");\n\t\t\tself.daysContainer.lastChild.classList.add(\"slideLeftNew\");\n\n\t\t\tself.oldCurMonth.classList.add(\"slideLeft\");\n\t\t\tself.navigationCurrentMonth.classList.add(\"slideLeftNew\");\n\t\t} else if (delta < 0) {\n\t\t\tself.daysContainer.firstChild.classList.add(\"slideRightNew\");\n\t\t\tself.daysContainer.lastChild.classList.add(\"slideRight\");\n\n\t\t\tself.oldCurMonth.classList.add(\"slideRight\");\n\t\t\tself.navigationCurrentMonth.classList.add(\"slideRightNew\");\n\t\t}\n\n\t\tself.currentMonthElement = self.navigationCurrentMonth.firstChild;\n\t\tself.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];\n\n\t\tupdateNavigationCurrentMonth();\n\t\tself.oldCurMonth.firstChild.textContent = self.utils.monthToStr(self.currentMonth - delta);\n\n\t\tif (self._.daysAnimDuration === undefined) {\n\t\t\tvar compStyle = window.getComputedStyle(self.daysContainer.lastChild);\n\n\t\t\tvar duration = compStyle.getPropertyValue(\"animation-duration\") || compStyle.getPropertyValue(\"-webkit-animation-duration\");\n\n\t\t\tself._.daysAnimDuration = parseInt(/(\\d+)s/.exec(duration)[1]);\n\t\t}\n\t}\n\n\tfunction clear(triggerChangeEvent) {\n\t\tself.input.value = \"\";\n\n\t\tif (self.altInput) self.altInput.value = \"\";\n\n\t\tif (self.mobileInput) self.mobileInput.value = \"\";\n\n\t\tself.selectedDates = [];\n\t\tself.latestSelectedDateObj = undefined;\n\t\tself.showTimeInput = false;\n\n\t\tself.redraw();\n\n\t\tif (triggerChangeEvent !== false)\n\t\t\t// triggerChangeEvent is true (default) or an Event\n\t\t\ttriggerEvent(\"Change\");\n\t}\n\n\tfunction close() {\n\t\tself.isOpen = false;\n\n\t\tif (!self.isMobile) {\n\t\t\tself.calendarContainer.classList.remove(\"open\");\n\t\t\tself._input.classList.remove(\"active\");\n\t\t}\n\n\t\ttriggerEvent(\"Close\");\n\t}\n\n\tfunction destroy(instance) {\n\t\tinstance = instance || self;\n\n\t\tfor (var i = instance._handlers.length; i--;) {\n\t\t\tvar h = instance._handlers[i];\n\t\t\th.element.removeEventListener(h.event, h.handler);\n\t\t}\n\n\t\tinstance._handlers = [];\n\n\t\tif (instance.mobileInput) {\n\t\t\tif (instance.mobileInput.parentNode) instance.mobileInput.parentNode.removeChild(instance.mobileInput);\n\t\t\tinstance.mobileInput = undefined;\n\t\t} else if (instance.calendarContainer && instance.calendarContainer.parentNode) instance.calendarContainer.parentNode.removeChild(instance.calendarContainer);\n\n\t\tif (instance.altInput) {\n\t\t\tinstance.input.type = \"text\";\n\t\t\tif (instance.altInput.parentNode) instance.altInput.parentNode.removeChild(instance.altInput);\n\t\t\tinstance.altInput = undefined;\n\t\t}\n\n\t\tif (instance.input) {\n\t\t\tinstance.input.type = instance.input._type;\n\t\t\tinstance.input.classList.remove(\"flatpickr-input\");\n\t\t\tinstance.input.removeAttribute(\"readonly\");\n\t\t\tinstance.input.value = \"\";\n\t\t}\n\n\t\tinstance.config = undefined;\n\t\tinstance.input._flatpickr = undefined;\n\t}\n\n\tfunction isCalendarElem(elem) {\n\t\tif (self.config.appendTo && self.config.appendTo.contains(elem)) return true;\n\n\t\treturn self.calendarContainer.contains(elem);\n\t}\n\n\tfunction documentClick(e) {\n\t\tif (self.isOpen && !self.config.inline) {\n\t\t\tvar isCalendarElement = isCalendarElem(e.target);\n\t\t\tvar isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) ||\n\t\t\t// web components\n\t\t\te.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));\n\n\t\t\tvar lostFocus = e.type === \"blur\" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;\n\n\t\t\tif (lostFocus) {\n\t\t\t\te.preventDefault();\n\t\t\t\tself.close();\n\n\t\t\t\tif (self.config.mode === \"range\" && self.selectedDates.length === 1) {\n\t\t\t\t\tself.clear();\n\t\t\t\t\tself.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction changeYear(newYear) {\n\t\tif (!newYear || self.currentYearElement.min && newYear < self.currentYearElement.min || self.currentYearElement.max && newYear > self.currentYearElement.max) return;\n\n\t\tvar newYearNum = parseInt(newYear, 10),\n\t\t    isNewYear = self.currentYear !== newYearNum;\n\n\t\tself.currentYear = newYearNum || self.currentYear;\n\n\t\tif (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {\n\t\t\tself.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);\n\t\t} else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {\n\t\t\tself.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);\n\t\t}\n\n\t\tif (isNewYear) {\n\t\t\tself.redraw();\n\t\t\ttriggerEvent(\"YearChange\");\n\t\t}\n\t}\n\n\tfunction isEnabled(date, timeless) {\n\t\tif (self.config.minDate && compareDates(date, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && compareDates(date, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;\n\n\t\tif (!self.config.enable.length && !self.config.disable.length) return true;\n\n\t\tvar dateToCheck = self.parseDate(date, null, true); // timeless\n\n\t\tvar bool = self.config.enable.length > 0,\n\t\t    array = bool ? self.config.enable : self.config.disable;\n\n\t\tfor (var i = 0, d; i < array.length; i++) {\n\t\t\td = array[i];\n\n\t\t\tif (d instanceof Function && d(dateToCheck)) // disabled by function\n\t\t\t\treturn bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime())\n\t\t\t\t// disabled by date\n\t\t\t\treturn bool;else if (typeof d === \"string\" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime())\n\t\t\t\t// disabled by date string\n\t\t\t\treturn bool;else if ( // disabled by range\n\t\t\t(typeof d === \"undefined\" ? \"undefined\" : _typeof(d)) === \"object\" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;\n\t\t}\n\n\t\treturn !bool;\n\t}\n\n\tfunction onKeyDown(e) {\n\t\tvar isInput = e.target === self._input;\n\t\tvar calendarElem = isCalendarElem(e.target);\n\t\tvar allowInput = self.config.allowInput;\n\t\tvar allowKeydown = self.isOpen && (!allowInput || !isInput);\n\t\tvar allowInlineKeydown = self.config.inline && isInput && !allowInput;\n\n\t\tif (e.key === \"Enter\" && allowInput && isInput) {\n\t\t\tself.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);\n\t\t\treturn e.target.blur();\n\t\t} else if (calendarElem || allowKeydown || allowInlineKeydown) {\n\t\t\tvar isTimeObj = self.timeContainer && self.timeContainer.contains(e.target);\n\t\t\tswitch (e.key) {\n\t\t\t\tcase \"Enter\":\n\t\t\t\t\tif (isTimeObj) updateValue();else selectDate(e);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Escape\":\n\t\t\t\t\t// escape\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tself.close();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ArrowLeft\":\n\t\t\t\tcase \"ArrowRight\":\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\tif (self.daysContainer) {\n\t\t\t\t\t\tvar _delta = e.key === \"ArrowRight\" ? 1 : -1;\n\n\t\t\t\t\t\tif (!e.ctrlKey) focusOnDay(e.target.$i, _delta);else {\n\t\t\t\t\t\t\tchangeMonth(_delta, true);\n\t\t\t\t\t\t\tafterDayAnim(function () {\n\t\t\t\t\t\t\t\tfocusOnDay(e.target.$i, 0);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (self.config.enableTime && !isTimeObj) self.hourElement.focus();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ArrowUp\":\n\t\t\t\tcase \"ArrowDown\":\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvar delta = e.key === \"ArrowDown\" ? 1 : -1;\n\n\t\t\t\t\tif (self.daysContainer) {\n\t\t\t\t\t\tif (e.ctrlKey) {\n\t\t\t\t\t\t\tchangeYear(self.currentYear - delta);\n\t\t\t\t\t\t\tfocusOnDay(e.target.$i, 0);\n\t\t\t\t\t\t} else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);\n\t\t\t\t\t} else if (self.config.enableTime) {\n\t\t\t\t\t\tif (!isTimeObj) self.hourElement.focus();\n\t\t\t\t\t\tupdateTime(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Tab\":\n\t\t\t\t\tif (e.target === self.hourElement) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tself.minuteElement.select();\n\t\t\t\t\t} else if (e.target === self.minuteElement && self.amPM) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tself.amPM.focus();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"a\":\n\t\t\t\t\tif (e.target === self.amPM) {\n\t\t\t\t\t\tself.amPM.textContent = \"AM\";\n\t\t\t\t\t\tsetHoursFromInputs();\n\t\t\t\t\t\tupdateValue();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"p\":\n\t\t\t\t\tif (e.target === self.amPM) {\n\t\t\t\t\t\tself.amPM.textContent = \"PM\";\n\t\t\t\t\t\tsetHoursFromInputs();\n\t\t\t\t\t\tupdateValue();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\ttriggerEvent(\"KeyDown\", e);\n\t\t}\n\t}\n\n\tfunction onMouseOver(elem) {\n\t\tif (self.selectedDates.length !== 1 || !elem.classList.contains(\"flatpickr-day\")) return;\n\n\t\tvar hoverDate = elem.dateObj,\n\t\t    initialDate = self.parseDate(self.selectedDates[0], null, true),\n\t\t    rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),\n\t\t    rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),\n\t\t    containsDisabled = false;\n\n\t\tfor (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {\n\t\t\tif (!isEnabled(new Date(t))) {\n\t\t\t\tcontainsDisabled = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar _loop = function _loop(timestamp, i) {\n\t\t\tvar outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime(),\n\t\t\t    dayElem = self.days.childNodes[i];\n\n\t\t\tif (outOfRange) {\n\t\t\t\tself.days.childNodes[i].classList.add(\"notAllowed\");\n\t\t\t\t[\"inRange\", \"startRange\", \"endRange\"].forEach(function (c) {\n\t\t\t\t\tdayElem.classList.remove(c);\n\t\t\t\t});\n\t\t\t\treturn \"continue\";\n\t\t\t} else if (containsDisabled && !outOfRange) return \"continue\";\n\n\t\t\t[\"startRange\", \"inRange\", \"endRange\", \"notAllowed\"].forEach(function (c) {\n\t\t\t\tdayElem.classList.remove(c);\n\t\t\t});\n\n\t\t\tvar minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),\n\t\t\t    maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);\n\n\t\t\telem.classList.add(hoverDate < self.selectedDates[0] ? \"startRange\" : \"endRange\");\n\n\t\t\tif (initialDate < hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add(\"startRange\");else if (initialDate > hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add(\"endRange\");\n\n\t\t\tif (timestamp >= minRangeDate && timestamp <= maxRangeDate) dayElem.classList.add(\"inRange\");\n\t\t};\n\n\t\tfor (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {\n\t\t\tvar _ret = _loop(timestamp, i);\n\n\t\t\tif (_ret === \"continue\") continue;\n\t\t}\n\t}\n\n\tfunction onResize() {\n\t\tif (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();\n\t}\n\n\tfunction open(e) {\n\t\tif (self.isMobile) {\n\t\t\tif (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.target.blur();\n\t\t\t}\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tself.mobileInput.click();\n\t\t\t}, 0);\n\n\t\t\ttriggerEvent(\"Open\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.isOpen || self._input.disabled || self.config.inline) return;\n\n\t\tself.isOpen = true;\n\t\tself.calendarContainer.classList.add(\"open\");\n\t\tpositionCalendar();\n\t\tself._input.classList.add(\"active\");\n\n\t\ttriggerEvent(\"Open\");\n\t}\n\n\tfunction minMaxDateSetter(type) {\n\t\treturn function (date) {\n\t\t\tvar dateObj = self.config[\"_\" + type + \"Date\"] = self.parseDate(date);\n\n\t\t\tvar inverseDateObj = self.config[\"_\" + (type === \"min\" ? \"max\" : \"min\") + \"Date\"];\n\t\t\tvar isValidDate = date && dateObj instanceof Date;\n\n\t\t\tif (isValidDate) {\n\t\t\t\tself[type + \"DateHasTime\"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();\n\t\t\t}\n\n\t\t\tif (self.selectedDates) {\n\t\t\t\tself.selectedDates = self.selectedDates.filter(function (d) {\n\t\t\t\t\treturn isEnabled(d);\n\t\t\t\t});\n\t\t\t\tif (!self.selectedDates.length && type === \"min\") setHoursFromDate(dateObj);\n\t\t\t\tupdateValue();\n\t\t\t}\n\n\t\t\tif (self.daysContainer) {\n\t\t\t\tredraw();\n\n\t\t\t\tif (isValidDate) self.currentYearElement[type] = dateObj.getFullYear();else self.currentYearElement.removeAttribute(type);\n\n\t\t\t\tself.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction parseConfig() {\n\t\tvar boolOpts = [\"utc\", \"wrap\", \"weekNumbers\", \"allowInput\", \"clickOpens\", \"time_24hr\", \"enableTime\", \"noCalendar\", \"altInput\", \"shorthandCurrentMonth\", \"inline\", \"static\", \"enableSeconds\", \"disableMobile\"];\n\n\t\tvar hooks = [\"onChange\", \"onClose\", \"onDayCreate\", \"onKeyDown\", \"onMonthChange\", \"onOpen\", \"onParseConfig\", \"onReady\", \"onValueUpdate\", \"onYearChange\"];\n\n\t\tself.config = Object.create(Flatpickr.defaultConfig);\n\n\t\tvar userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));\n\n\t\tself.config.parseDate = userConfig.parseDate;\n\t\tself.config.formatDate = userConfig.formatDate;\n\n\t\t_extends(self.config, userConfig);\n\n\t\tif (!userConfig.dateFormat && userConfig.enableTime) {\n\t\t\tself.config.dateFormat = self.config.noCalendar ? \"H:i\" + (self.config.enableSeconds ? \":S\" : \"\") : Flatpickr.defaultConfig.dateFormat + \" H:i\" + (self.config.enableSeconds ? \":S\" : \"\");\n\t\t}\n\n\t\tif (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {\n\t\t\tself.config.altFormat = self.config.noCalendar ? \"h:i\" + (self.config.enableSeconds ? \":S K\" : \" K\") : Flatpickr.defaultConfig.altFormat + (\" h:i\" + (self.config.enableSeconds ? \":S\" : \"\") + \" K\");\n\t\t}\n\n\t\tObject.defineProperty(self.config, \"minDate\", {\n\t\t\tget: function get() {\n\t\t\t\treturn this._minDate;\n\t\t\t},\n\t\t\tset: minMaxDateSetter(\"min\")\n\t\t});\n\n\t\tObject.defineProperty(self.config, \"maxDate\", {\n\t\t\tget: function get() {\n\t\t\t\treturn this._maxDate;\n\t\t\t},\n\t\t\tset: minMaxDateSetter(\"max\")\n\t\t});\n\n\t\tself.config.minDate = userConfig.minDate;\n\t\tself.config.maxDate = userConfig.maxDate;\n\n\t\tfor (var i = 0; i < boolOpts.length; i++) {\n\t\t\tself.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === \"true\";\n\t\t}for (var _i = 0; _i < hooks.length; _i++) {\n\t\t\tself.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);\n\t\t}for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {\n\t\t\tvar pluginConf = self.config.plugins[_i2](self) || {};\n\t\t\tfor (var key in pluginConf) {\n\n\t\t\t\tif ((self.config[key] || ~hooks.indexOf(key)) instanceof Array) {\n\t\t\t\t\tself.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);\n\t\t\t\t} else if (typeof userConfig[key] === \"undefined\") self.config[key] = pluginConf[key];\n\t\t\t}\n\t\t}\n\n\t\ttriggerEvent(\"ParseConfig\");\n\t}\n\n\tfunction setupLocale() {\n\t\tif (_typeof(self.config.locale) !== \"object\" && typeof Flatpickr.l10ns[self.config.locale] === \"undefined\") console.warn(\"flatpickr: invalid locale \" + self.config.locale);\n\n\t\tself.l10n = _extends(Object.create(Flatpickr.l10ns.default), _typeof(self.config.locale) === \"object\" ? self.config.locale : self.config.locale !== \"default\" ? Flatpickr.l10ns[self.config.locale] || {} : {});\n\t}\n\n\tfunction positionCalendar() {\n\t\tif (self.calendarContainer === undefined) return;\n\n\t\tvar calendarHeight = self.calendarContainer.offsetHeight,\n\t\t    calendarWidth = self.calendarContainer.offsetWidth,\n\t\t    configPos = self.config.position,\n\t\t    inputBounds = self._input.getBoundingClientRect(),\n\t\t    distanceFromBottom = window.innerHeight - inputBounds.bottom,\n\t\t    showOnTop = configPos === \"above\" || configPos !== \"below\" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;\n\n\t\tvar top = window.pageYOffset + inputBounds.top + (!showOnTop ? self._input.offsetHeight + 2 : -calendarHeight - 2);\n\n\t\ttoggleClass(self.calendarContainer, \"arrowTop\", !showOnTop);\n\t\ttoggleClass(self.calendarContainer, \"arrowBottom\", showOnTop);\n\n\t\tif (self.config.inline) return;\n\n\t\tvar left = window.pageXOffset + inputBounds.left;\n\t\tvar right = window.document.body.offsetWidth - inputBounds.right;\n\t\tvar rightMost = left + calendarWidth > window.document.body.offsetWidth;\n\n\t\ttoggleClass(self.calendarContainer, \"rightMost\", rightMost);\n\n\t\tif (self.config.static) return;\n\n\t\tself.calendarContainer.style.top = top + \"px\";\n\n\t\tif (!rightMost) {\n\t\t\tself.calendarContainer.style.left = left + \"px\";\n\t\t\tself.calendarContainer.style.right = \"auto\";\n\t\t} else {\n\t\t\tself.calendarContainer.style.left = \"auto\";\n\t\t\tself.calendarContainer.style.right = right + \"px\";\n\t\t}\n\t}\n\n\tfunction redraw() {\n\t\tif (self.config.noCalendar || self.isMobile) return;\n\n\t\tbuildWeekdays();\n\t\tupdateNavigationCurrentMonth();\n\t\tbuildDays();\n\t}\n\n\tfunction selectDate(e) {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\n\t\tif (!e.target.classList.contains(\"flatpickr-day\") || e.target.classList.contains(\"disabled\") || e.target.classList.contains(\"notAllowed\")) return;\n\n\t\tvar selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());\n\n\t\tvar shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth && self.config.mode !== \"range\";\n\n\t\tself.selectedDateElem = e.target;\n\n\t\tif (self.config.mode === \"single\") self.selectedDates = [selectedDate];else if (self.config.mode === \"multiple\") {\n\t\t\tvar selectedIndex = isDateSelected(selectedDate);\n\t\t\tif (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);\n\t\t} else if (self.config.mode === \"range\") {\n\t\t\tif (self.selectedDates.length === 2) self.clear();\n\n\t\t\tself.selectedDates.push(selectedDate);\n\n\t\t\t// unless selecting same date twice, sort ascendingly\n\t\t\tif (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {\n\t\t\t\treturn a.getTime() - b.getTime();\n\t\t\t});\n\t\t}\n\n\t\tsetHoursFromInputs();\n\n\t\tif (shouldChangeMonth) {\n\t\t\tvar isNewYear = self.currentYear !== selectedDate.getFullYear();\n\t\t\tself.currentYear = selectedDate.getFullYear();\n\t\t\tself.currentMonth = selectedDate.getMonth();\n\n\t\t\tif (isNewYear) triggerEvent(\"YearChange\");\n\n\t\t\ttriggerEvent(\"MonthChange\");\n\t\t}\n\n\t\tbuildDays();\n\n\t\tif (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);\n\n\t\tupdateValue();\n\n\t\tif (self.config.enableTime) setTimeout(function () {\n\t\t\treturn self.showTimeInput = true;\n\t\t}, 50);\n\n\t\tif (self.config.mode === \"range\") {\n\t\t\tif (self.selectedDates.length === 1) {\n\t\t\t\tonMouseOver(e.target);\n\n\t\t\t\tself._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > self.days.childNodes[0].dateObj;\n\n\t\t\t\tself._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n\t\t\t} else {\n\t\t\t\tupdateNavigationCurrentMonth();\n\t\t\t\tself.close();\n\t\t\t}\n\t\t}\n\n\t\ttriggerEvent(\"Change\");\n\n\t\t// maintain focus\n\t\tif (!shouldChangeMonth) focusOnDay(e.target.$i, 0);else afterDayAnim(function () {\n\t\t\treturn self.selectedDateElem.focus();\n\t\t});\n\n\t\tif (self.config.enableTime) setTimeout(function () {\n\t\t\treturn self.hourElement.select();\n\t\t}, 451);\n\n\t\tif (self.config.mode === \"single\" && !self.config.enableTime) self.close();\n\t}\n\n\tfunction set(option, value) {\n\t\tself.config[option] = value;\n\t\tself.redraw();\n\t\tjumpToDate();\n\t}\n\n\tfunction setSelectedDate(inputDate, format) {\n\t\tif (inputDate instanceof Array) self.selectedDates = inputDate.map(function (d) {\n\t\t\treturn self.parseDate(d, format);\n\t\t});else if (inputDate instanceof Date || !isNaN(inputDate)) self.selectedDates = [self.parseDate(inputDate, format)];else if (inputDate && inputDate.substring) {\n\t\t\tswitch (self.config.mode) {\n\t\t\t\tcase \"single\":\n\t\t\t\t\tself.selectedDates = [self.parseDate(inputDate, format)];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"multiple\":\n\t\t\t\t\tself.selectedDates = inputDate.split(\"; \").map(function (date) {\n\t\t\t\t\t\treturn self.parseDate(date, format);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"range\":\n\t\t\t\t\tself.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {\n\t\t\t\t\t\treturn self.parseDate(date, format);\n\t\t\t\t\t});\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tself.selectedDates = self.selectedDates.filter(function (d) {\n\t\t\treturn d instanceof Date && isEnabled(d, false);\n\t\t});\n\n\t\tself.selectedDates.sort(function (a, b) {\n\t\t\treturn a.getTime() - b.getTime();\n\t\t});\n\t}\n\n\tfunction setDate(date, triggerChange, format) {\n\t\tif (!date) return self.clear(triggerChange);\n\n\t\tsetSelectedDate(date, format);\n\n\t\tself.showTimeInput = self.selectedDates.length > 0;\n\t\tself.latestSelectedDateObj = self.selectedDates[0];\n\n\t\tself.redraw();\n\t\tjumpToDate();\n\n\t\tsetHoursFromDate();\n\t\tupdateValue();\n\n\t\tif (triggerChange) triggerEvent(\"Change\");\n\t}\n\n\tfunction setupDates() {\n\t\tfunction parseDateRules(arr) {\n\t\t\tfor (var i = arr.length; i--;) {\n\t\t\t\tif (typeof arr[i] === \"string\" || +arr[i]) arr[i] = self.parseDate(arr[i], null, true);else if (arr[i] && arr[i].from && arr[i].to) {\n\t\t\t\t\tarr[i].from = self.parseDate(arr[i].from);\n\t\t\t\t\tarr[i].to = self.parseDate(arr[i].to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arr.filter(function (x) {\n\t\t\t\treturn x;\n\t\t\t}); // remove falsy values\n\t\t}\n\n\t\tself.selectedDates = [];\n\t\tself.now = new Date();\n\n\t\tif (self.config.disable.length) self.config.disable = parseDateRules(self.config.disable);\n\n\t\tif (self.config.enable.length) self.config.enable = parseDateRules(self.config.enable);\n\n\t\tvar preloadedDate = self.config.defaultDate || self.input.value;\n\t\tif (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);\n\n\t\tvar initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;\n\n\t\tself.currentYear = initialDate.getFullYear();\n\t\tself.currentMonth = initialDate.getMonth();\n\n\t\tif (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];\n\n\t\tself.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());\n\n\t\tself.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());\n\n\t\tObject.defineProperty(self, \"latestSelectedDateObj\", {\n\t\t\tget: function get() {\n\t\t\t\treturn self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1];\n\t\t\t},\n\t\t\tset: function set(date) {\n\t\t\t\tself._selectedDateObj = date;\n\t\t\t}\n\t\t});\n\n\t\tif (!self.isMobile) {\n\t\t\tObject.defineProperty(self, \"showTimeInput\", {\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn self._showTimeInput;\n\t\t\t\t},\n\t\t\t\tset: function set(bool) {\n\t\t\t\t\tself._showTimeInput = bool;\n\t\t\t\t\tif (self.calendarContainer) toggleClass(self.calendarContainer, \"showTimeInput\", bool);\n\t\t\t\t\tpositionCalendar();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setupHelperFunctions() {\n\t\tself.utils = {\n\t\t\tduration: {\n\t\t\t\tDAY: 86400000\n\t\t\t},\n\t\t\tgetDaysinMonth: function getDaysinMonth(month, yr) {\n\t\t\t\tmonth = typeof month === \"undefined\" ? self.currentMonth : month;\n\n\t\t\t\tyr = typeof yr === \"undefined\" ? self.currentYear : yr;\n\n\t\t\t\tif (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;\n\n\t\t\t\treturn self.l10n.daysInMonth[month];\n\t\t\t},\n\t\t\tmonthToStr: function monthToStr(monthNumber, shorthand) {\n\t\t\t\tshorthand = typeof shorthand === \"undefined\" ? self.config.shorthandCurrentMonth : shorthand;\n\n\t\t\t\treturn self.l10n.months[(shorthand ? \"short\" : \"long\") + \"hand\"][monthNumber];\n\t\t\t}\n\t\t};\n\t}\n\n\t/* istanbul ignore next */\n\tfunction setupFormats() {\n\t\t[\"D\", \"F\", \"J\", \"M\", \"W\", \"l\"].forEach(function (f) {\n\t\t\tself.formats[f] = Flatpickr.prototype.formats[f].bind(self);\n\t\t});\n\n\t\tself.revFormat.F = Flatpickr.prototype.revFormat.F.bind(self);\n\t\tself.revFormat.M = Flatpickr.prototype.revFormat.M.bind(self);\n\t}\n\n\tfunction setupInputs() {\n\t\tself.input = self.config.wrap ? self.element.querySelector(\"[data-input]\") : self.element;\n\n\t\t/* istanbul ignore next */\n\t\tif (!self.input) return console.warn(\"Error: invalid input element specified\", self.input);\n\n\t\tself.input._type = self.input.type;\n\t\tself.input.type = \"text\";\n\n\t\tself.input.classList.add(\"flatpickr-input\");\n\t\tself._input = self.input;\n\n\t\tif (self.config.altInput) {\n\t\t\t// replicate self.element\n\t\t\tself.altInput = createElement(self.input.nodeName, self.input.className + \" \" + self.config.altInputClass);\n\t\t\tself._input = self.altInput;\n\t\t\tself.altInput.placeholder = self.input.placeholder;\n\t\t\tself.altInput.type = \"text\";\n\t\t\tself.input.type = \"hidden\";\n\n\t\t\tif (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);\n\t\t}\n\n\t\tif (!self.config.allowInput) self._input.setAttribute(\"readonly\", \"readonly\");\n\t}\n\n\tfunction setupMobile() {\n\t\tvar inputType = self.config.enableTime ? self.config.noCalendar ? \"time\" : \"datetime-local\" : \"date\";\n\n\t\tself.mobileInput = createElement(\"input\", self.input.className + \" flatpickr-mobile\");\n\t\tself.mobileInput.step = \"any\";\n\t\tself.mobileInput.tabIndex = 1;\n\t\tself.mobileInput.type = inputType;\n\t\tself.mobileInput.disabled = self.input.disabled;\n\t\tself.mobileInput.placeholder = self.input.placeholder;\n\n\t\tself.mobileFormatStr = inputType === \"datetime-local\" ? \"Y-m-d\\\\TH:i:S\" : inputType === \"date\" ? \"Y-m-d\" : \"H:i:S\";\n\n\t\tif (self.selectedDates.length) {\n\t\t\tself.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);\n\t\t}\n\n\t\tif (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, \"Y-m-d\");\n\n\t\tif (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, \"Y-m-d\");\n\n\t\tself.input.type = \"hidden\";\n\t\tif (self.config.altInput) self.altInput.type = \"hidden\";\n\n\t\ttry {\n\t\t\tself.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);\n\t\t} catch (e) {\n\t\t\t//\n\t\t}\n\n\t\tself.mobileInput.addEventListener(\"change\", function (e) {\n\t\t\tself.setDate(e.target.value, false, self.mobileFormatStr);\n\t\t\ttriggerEvent(\"Change\");\n\t\t\ttriggerEvent(\"Close\");\n\t\t});\n\t}\n\n\tfunction toggle() {\n\t\tif (self.isOpen) return self.close();\n\t\tself.open();\n\t}\n\n\tfunction triggerEvent(event, data) {\n\t\tvar hooks = self.config[\"on\" + event];\n\n\t\tif (hooks) {\n\t\t\tfor (var i = 0; hooks[i] && i < hooks.length; i++) {\n\t\t\t\thooks[i](self.selectedDates, self.input && self.input.value, self, data);\n\t\t\t}\n\t\t}\n\n\t\tif (event === \"Change\") {\n\t\t\tself.input.dispatchEvent(createEvent(\"change\"));\n\n\t\t\t// many front-end frameworks bind to the input event\n\t\t\tself.input.dispatchEvent(createEvent(\"input\"));\n\t\t}\n\t}\n\n\t/**\n  * Creates an Event, normalized across browsers\n  * @param {String} name the event name, e.g. \"click\"\n  * @return {Event} the created event\n  */\n\tfunction createEvent(name) {\n\t\tvar existing = self._[name + \"Event\"];\n\t\tif (existing !== undefined) return existing;\n\n\t\tif (self._supportsEvents) return self._[name + \"Event\"] = new Event(name, { bubbles: true });\n\n\t\tself._[name + \"Event\"] = document.createEvent(\"Event\");\n\t\tself._[name + \"Event\"].initEvent(name, true, true);\n\t\treturn self._[name + \"Event\"];\n\t}\n\n\tfunction isDateSelected(date) {\n\t\tfor (var i = 0; i < self.selectedDates.length; i++) {\n\t\t\tif (compareDates(self.selectedDates[i], date) === 0) return \"\" + i;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction isDateInRange(date) {\n\t\tif (self.config.mode !== \"range\" || self.selectedDates.length < 2) return false;\n\t\treturn compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;\n\t}\n\n\tfunction updateNavigationCurrentMonth() {\n\t\tif (self.config.noCalendar || self.isMobile || !self.monthNav) return;\n\n\t\tself.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + \" \";\n\t\tself.currentYearElement.value = self.currentYear;\n\n\t\tself._hidePrevMonthArrow = self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());\n\n\t\tself._hideNextMonthArrow = self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());\n\t}\n\n\t/**\n  * Updates the values of inputs associated with the calendar\n  * @return {void}\n  */\n\tfunction updateValue() {\n\t\tif (!self.selectedDates.length) return self.clear();\n\n\t\tif (self.isMobile) {\n\t\t\tself.mobileInput.value = self.selectedDates.length ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : \"\";\n\t\t}\n\n\t\tvar joinChar = self.config.mode !== \"range\" ? \"; \" : self.l10n.rangeSeparator;\n\n\t\tself.input.value = self.selectedDates.map(function (dObj) {\n\t\t\treturn self.formatDate(dObj, self.config.dateFormat);\n\t\t}).join(joinChar);\n\n\t\tif (self.config.altInput) {\n\t\t\tself.altInput.value = self.selectedDates.map(function (dObj) {\n\t\t\t\treturn self.formatDate(dObj, self.config.altFormat);\n\t\t\t}).join(joinChar);\n\t\t}\n\n\t\ttriggerEvent(\"ValueUpdate\");\n\t}\n\n\tfunction mouseDelta(e) {\n\t\treturn Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));\n\t}\n\n\tfunction onMonthNavScroll(e) {\n\t\te.preventDefault();\n\t\tvar isYear = self.currentYearElement.parentNode.contains(e.target);\n\n\t\tif (e.target === self.currentMonthElement || isYear) {\n\n\t\t\tvar delta = mouseDelta(e);\n\n\t\t\tif (isYear) {\n\t\t\t\tchangeYear(self.currentYear + delta);\n\t\t\t\te.target.value = self.currentYear;\n\t\t\t} else self.changeMonth(delta, true, false);\n\t\t}\n\t}\n\n\tfunction onMonthNavClick(e) {\n\t\tif (e.target.className === \"arrowUp\") self.changeYear(self.currentYear + 1);else if (e.target.className === \"arrowDown\") self.changeYear(self.currentYear - 1);\n\t}\n\n\t/**\n  * Creates an HTMLElement with given tag, class, and textual content\n  * @param {String} tag the HTML tag\n  * @param {String} className the new element's class name\n  * @param {String} content The new element's text content\n  * @return {HTMLElement} the created HTML element\n  */\n\tfunction createElement(tag, className, content) {\n\t\tvar e = window.document.createElement(tag);\n\t\tclassName = className || \"\";\n\t\tcontent = content || \"\";\n\n\t\te.className = className;\n\n\t\tif (content !== undefined) e.textContent = content;\n\n\t\treturn e;\n\t}\n\n\tfunction arrayify(obj) {\n\t\tif (obj instanceof Array) return obj;\n\t\treturn [obj];\n\t}\n\n\tfunction toggleClass(elem, className, bool) {\n\t\tif (bool) return elem.classList.add(className);\n\t\telem.classList.remove(className);\n\t}\n\n\t/* istanbul ignore next */\n\tfunction debounce(func, wait, immediate) {\n\t\tvar timeout = void 0;\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments;\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(function () {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t}, wait);\n\t\t\tif (immediate && !timeout) func.apply(context, args);\n\t\t};\n\t}\n\n\t/**\n  * Compute the difference in dates, measured in ms\n  * @param {Date} date1\n  * @param {Date} date2\n  * @param {Boolean} timeless whether to reset times of both dates to 00:00\n  * @return {Number} the difference in ms\n  */\n\tfunction compareDates(date1, date2, timeless) {\n\t\tif (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;\n\n\t\tif (timeless !== false) {\n\t\t\treturn new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);\n\t\t}\n\n\t\treturn date1.getTime() - date2.getTime();\n\t}\n\n\tfunction timeWrapper(e) {\n\t\te.preventDefault();\n\n\t\tvar isKeyDown = e.type === \"keydown\",\n\t\t    isWheel = e.type === \"wheel\",\n\t\t    isIncrement = e.type === \"increment\",\n\t\t    input = e.target;\n\n\t\tif (self.amPM && e.target === self.amPM) return e.target.textContent = [\"AM\", \"PM\"][e.target.textContent === \"AM\" | 0];\n\n\t\tvar min = Number(input.min),\n\t\t    max = Number(input.max),\n\t\t    step = Number(input.step),\n\t\t    curValue = parseInt(input.value, 10),\n\t\t    delta = e.delta || (!isKeyDown ? Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)) || 0 : e.which === 38 ? 1 : -1);\n\n\t\tvar newValue = curValue + step * delta;\n\n\t\tif (typeof input.value !== \"undefined\" && input.value.length === 2) {\n\t\t\tvar isHourElem = input === self.hourElement,\n\t\t\t    isMinuteElem = input === self.minuteElement;\n\n\t\t\tif (newValue < min) {\n\t\t\t\tnewValue = max + newValue + !isHourElem + (isHourElem && !self.amPM);\n\n\t\t\t\tif (isMinuteElem) incrementNumInput(null, -1, self.hourElement);\n\t\t\t} else if (newValue > max) {\n\t\t\t\tnewValue = input === self.hourElement ? newValue - max - !self.amPM : min;\n\n\t\t\t\tif (isMinuteElem) incrementNumInput(null, 1, self.hourElement);\n\t\t\t}\n\n\t\t\tif (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === \"PM\" ? \"AM\" : \"PM\";\n\n\t\t\tinput.value = self.pad(newValue);\n\t\t}\n\t}\n\n\tinit();\n\treturn self;\n}\n\n/* istanbul ignore next */\nFlatpickr.defaultConfig = {\n\tmode: \"single\",\n\n\tposition: \"auto\",\n\n\tanimate: window.navigator.userAgent.indexOf(\"MSIE\") === -1,\n\n\t/* if true, dates will be parsed, formatted, and displayed in UTC.\n preloading date strings w/ timezones is recommended but not necessary */\n\tutc: false,\n\n\t// wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements\n\twrap: false,\n\n\t// enables week numbers\n\tweekNumbers: false,\n\n\t// allow manual datetime input\n\tallowInput: false,\n\n\t/*\n \tclicking on input opens the date(time)picker.\n \tdisable if you wish to open the calendar manually with .open()\n */\n\tclickOpens: true,\n\n\t// display time picker in 24 hour mode\n\ttime_24hr: false,\n\n\t// enables the time picker functionality\n\tenableTime: false,\n\n\t// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime\n\tnoCalendar: false,\n\n\t// more date format chars at https://chmln.github.io/flatpickr/#dateformat\n\tdateFormat: \"Y-m-d\",\n\n\t// altInput - see https://chmln.github.io/flatpickr/#altinput\n\taltInput: false,\n\n\t// the created altInput element will have this class.\n\taltInputClass: \"flatpickr-input form-control input\",\n\n\t// same as dateFormat, but for altInput\n\taltFormat: \"F j, Y\", // defaults to e.g. June 10, 2016\n\n\t// defaultDate - either a datestring or a date object. used for datetimepicker\"s initial value\n\tdefaultDate: null,\n\n\t// the minimum date that user can pick (inclusive)\n\tminDate: null,\n\n\t// the maximum date that user can pick (inclusive)\n\tmaxDate: null,\n\n\t// dateparser that transforms a given string to a date object\n\tparseDate: null,\n\n\t// dateformatter that transforms a given date object to a string, according to passed format\n\tformatDate: null,\n\n\tgetWeek: function getWeek(givenDate) {\n\t\tvar date = new Date(givenDate.getTime());\n\t\tvar onejan = new Date(date.getFullYear(), 0, 1);\n\t\treturn Math.ceil(((date - onejan) / 86400000 + onejan.getDay() + 1) / 7);\n\t},\n\n\n\t// see https://chmln.github.io/flatpickr/#disable\n\tenable: [],\n\n\t// see https://chmln.github.io/flatpickr/#disable\n\tdisable: [],\n\n\t// display the short version of month names - e.g. Sep instead of September\n\tshorthandCurrentMonth: false,\n\n\t// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar\n\tinline: false,\n\n\t// position calendar inside wrapper and next to the input element\n\t// leave at false unless you know what you\"re doing\n\t\"static\": false,\n\n\t// DOM node to append the calendar to in *static* mode\n\tappendTo: null,\n\n\t// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome\n\tprevArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>\",\n\tnextArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>\",\n\n\t// enables seconds in the time picker\n\tenableSeconds: false,\n\n\t// step size used when scrolling/incrementing the hour element\n\thourIncrement: 1,\n\n\t// step size used when scrolling/incrementing the minute element\n\tminuteIncrement: 5,\n\n\t// initial value in the hour element\n\tdefaultHour: 12,\n\n\t// initial value in the minute element\n\tdefaultMinute: 0,\n\n\t// disable native mobile datetime input support\n\tdisableMobile: false,\n\n\t// default locale\n\tlocale: \"default\",\n\n\tplugins: [],\n\n\t// called every time calendar is closed\n\tonClose: [], // function (dateObj, dateStr) {}\n\n\t// onChange callback when user selects a date or time\n\tonChange: [], // function (dateObj, dateStr) {}\n\n\t// called for every day element\n\tonDayCreate: [],\n\n\t// called every time the month is changed\n\tonMonthChange: [],\n\n\t// called every time calendar is opened\n\tonOpen: [], // function (dateObj, dateStr) {}\n\n\t// called after the configuration has been parsed\n\tonParseConfig: [],\n\n\t// called after calendar is ready\n\tonReady: [], // function (dateObj, dateStr) {}\n\n\t// called after input value updated\n\tonValueUpdate: [],\n\n\t// called every time the year is changed\n\tonYearChange: [],\n\n\tonKeyDown: []\n};\n\n/* istanbul ignore next */\nFlatpickr.l10ns = {\n\ten: {\n\t\tweekdays: {\n\t\t\tshorthand: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n\t\t\tlonghand: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n\t\t},\n\t\tmonths: {\n\t\t\tshorthand: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n\t\t\tlonghand: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n\t\t},\n\t\tdaysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n\t\tfirstDayOfWeek: 0,\n\t\tordinal: function ordinal(nth) {\n\t\t\tvar s = nth % 100;\n\t\t\tif (s > 3 && s < 21) return \"th\";\n\t\t\tswitch (s % 10) {\n\t\t\t\tcase 1:\n\t\t\t\t\treturn \"st\";\n\t\t\t\tcase 2:\n\t\t\t\t\treturn \"nd\";\n\t\t\t\tcase 3:\n\t\t\t\t\treturn \"rd\";\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"th\";\n\t\t\t}\n\t\t},\n\t\trangeSeparator: \" to \",\n\t\tweekAbbreviation: \"Wk\",\n\t\tscrollTitle: \"Scroll to increment\",\n\t\ttoggleTitle: \"Click to toggle\"\n\t}\n};\n\nFlatpickr.l10ns.default = Object.create(Flatpickr.l10ns.en);\nFlatpickr.localize = function (l10n) {\n\treturn _extends(Flatpickr.l10ns.default, l10n || {});\n};\nFlatpickr.setDefaults = function (config) {\n\treturn _extends(Flatpickr.defaultConfig, config || {});\n};\n\nFlatpickr.prototype = {\n\tformats: {\n\t\t// get the date in UTC\n\t\tZ: function Z(date) {\n\t\t\treturn date.toISOString();\n\t\t},\n\n\t\t// weekday name, short, e.g. Thu\n\t\tD: function D(date) {\n\t\t\treturn this.l10n.weekdays.shorthand[this.formats.w(date)];\n\t\t},\n\n\t\t// full month name e.g. January\n\t\tF: function F(date) {\n\t\t\treturn this.utils.monthToStr(this.formats.n(date) - 1, false);\n\t\t},\n\n\t\t// hours with leading zero e.g. 03\n\t\tH: function H(date) {\n\t\t\treturn Flatpickr.prototype.pad(date.getHours());\n\t\t},\n\n\t\t// day (1-30) with ordinal suffix e.g. 1st, 2nd\n\t\tJ: function J(date) {\n\t\t\treturn date.getDate() + this.l10n.ordinal(date.getDate());\n\t\t},\n\n\t\t// AM/PM\n\t\tK: function K(date) {\n\t\t\treturn date.getHours() > 11 ? \"PM\" : \"AM\";\n\t\t},\n\n\t\t// shorthand month e.g. Jan, Sep, Oct, etc\n\t\tM: function M(date) {\n\t\t\treturn this.utils.monthToStr(date.getMonth(), true);\n\t\t},\n\n\t\t// seconds 00-59\n\t\tS: function S(date) {\n\t\t\treturn Flatpickr.prototype.pad(date.getSeconds());\n\t\t},\n\n\t\t// unix timestamp\n\t\tU: function U(date) {\n\t\t\treturn date.getTime() / 1000;\n\t\t},\n\n\t\tW: function W(date) {\n\t\t\treturn this.config.getWeek(date);\n\t\t},\n\n\t\t// full year e.g. 2016\n\t\tY: function Y(date) {\n\t\t\treturn date.getFullYear();\n\t\t},\n\n\t\t// day in month, padded (01-30)\n\t\td: function d(date) {\n\t\t\treturn Flatpickr.prototype.pad(date.getDate());\n\t\t},\n\n\t\t// hour from 1-12 (am/pm)\n\t\th: function h(date) {\n\t\t\treturn date.getHours() % 12 ? date.getHours() % 12 : 12;\n\t\t},\n\n\t\t// minutes, padded with leading zero e.g. 09\n\t\ti: function i(date) {\n\t\t\treturn Flatpickr.prototype.pad(date.getMinutes());\n\t\t},\n\n\t\t// day in month (1-30)\n\t\tj: function j(date) {\n\t\t\treturn date.getDate();\n\t\t},\n\n\t\t// weekday name, full, e.g. Thursday\n\t\tl: function l(date) {\n\t\t\treturn this.l10n.weekdays.longhand[date.getDay()];\n\t\t},\n\n\t\t// padded month number (01-12)\n\t\tm: function m(date) {\n\t\t\treturn Flatpickr.prototype.pad(date.getMonth() + 1);\n\t\t},\n\n\t\t// the month number (1-12)\n\t\tn: function n(date) {\n\t\t\treturn date.getMonth() + 1;\n\t\t},\n\n\t\t// seconds 0-59\n\t\ts: function s(date) {\n\t\t\treturn date.getSeconds();\n\t\t},\n\n\t\t// number of the day of the week\n\t\tw: function w(date) {\n\t\t\treturn date.getDay();\n\t\t},\n\n\t\t// last two digits of year e.g. 16 for 2016\n\t\ty: function y(date) {\n\t\t\treturn String(date.getFullYear()).substring(2);\n\t\t}\n\t},\n\n\t/**\n  * Formats a given Date object into a string based on supplied format\n  * @param {Date} dateObj the date object\n  * @param {String} frmt a string composed of formatting tokens e.g. \"Y-m-d\"\n  * @return {String} The textual representation of the date e.g. 2017-02-03\n  */\n\tformatDate: function formatDate(dateObj, frmt) {\n\t\tvar _this = this;\n\n\t\tif (this.config !== undefined && this.config.formatDate !== undefined) return this.config.formatDate(dateObj, frmt);\n\n\t\treturn frmt.split(\"\").map(function (c, i, arr) {\n\t\t\treturn _this.formats[c] && arr[i - 1] !== \"\\\\\" ? _this.formats[c](dateObj) : c !== \"\\\\\" ? c : \"\";\n\t\t}).join(\"\");\n\t},\n\n\n\trevFormat: {\n\t\tD: function D() {},\n\t\tF: function F(dateObj, monthName) {\n\t\t\tdateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));\n\t\t},\n\t\tH: function H(dateObj, hour) {\n\t\t\tdateObj.setHours(parseFloat(hour));\n\t\t},\n\t\tJ: function J(dateObj, day) {\n\t\t\tdateObj.setDate(parseFloat(day));\n\t\t},\n\t\tK: function K(dateObj, amPM) {\n\t\t\tvar hours = dateObj.getHours();\n\n\t\t\tif (hours !== 12) dateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));\n\t\t},\n\t\tM: function M(dateObj, shortMonth) {\n\t\t\tdateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));\n\t\t},\n\t\tS: function S(dateObj, seconds) {\n\t\t\tdateObj.setSeconds(seconds);\n\t\t},\n\t\tU: function U(dateObj, unixSeconds) {\n\t\t\treturn new Date(parseFloat(unixSeconds) * 1000);\n\t\t},\n\n\t\tW: function W(dateObj, weekNumber) {\n\t\t\tweekNumber = parseInt(weekNumber);\n\t\t\treturn new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);\n\t\t},\n\t\tY: function Y(dateObj, year) {\n\t\t\tdateObj.setFullYear(year);\n\t\t},\n\t\tZ: function Z(dateObj, ISODate) {\n\t\t\treturn new Date(ISODate);\n\t\t},\n\n\t\td: function d(dateObj, day) {\n\t\t\tdateObj.setDate(parseFloat(day));\n\t\t},\n\t\th: function h(dateObj, hour) {\n\t\t\tdateObj.setHours(parseFloat(hour));\n\t\t},\n\t\ti: function i(dateObj, minutes) {\n\t\t\tdateObj.setMinutes(parseFloat(minutes));\n\t\t},\n\t\tj: function j(dateObj, day) {\n\t\t\tdateObj.setDate(parseFloat(day));\n\t\t},\n\t\tl: function l() {},\n\t\tm: function m(dateObj, month) {\n\t\t\tdateObj.setMonth(parseFloat(month) - 1);\n\t\t},\n\t\tn: function n(dateObj, month) {\n\t\t\tdateObj.setMonth(parseFloat(month) - 1);\n\t\t},\n\t\ts: function s(dateObj, seconds) {\n\t\t\tdateObj.setSeconds(parseFloat(seconds));\n\t\t},\n\t\tw: function w() {},\n\t\ty: function y(dateObj, year) {\n\t\t\tdateObj.setFullYear(2000 + parseFloat(year));\n\t\t}\n\t},\n\n\ttokenRegex: {\n\t\tD: \"(\\\\w+)\",\n\t\tF: \"(\\\\w+)\",\n\t\tH: \"(\\\\d\\\\d|\\\\d)\",\n\t\tJ: \"(\\\\d\\\\d|\\\\d)\\\\w+\",\n\t\tK: \"(\\\\w+)\",\n\t\tM: \"(\\\\w+)\",\n\t\tS: \"(\\\\d\\\\d|\\\\d)\",\n\t\tU: \"(.+)\",\n\t\tW: \"(\\\\d\\\\d|\\\\d)\",\n\t\tY: \"(\\\\d{4})\",\n\t\tZ: \"(.+)\",\n\t\td: \"(\\\\d\\\\d|\\\\d)\",\n\t\th: \"(\\\\d\\\\d|\\\\d)\",\n\t\ti: \"(\\\\d\\\\d|\\\\d)\",\n\t\tj: \"(\\\\d\\\\d|\\\\d)\",\n\t\tl: \"(\\\\w+)\",\n\t\tm: \"(\\\\d\\\\d|\\\\d)\",\n\t\tn: \"(\\\\d\\\\d|\\\\d)\",\n\t\ts: \"(\\\\d\\\\d|\\\\d)\",\n\t\tw: \"(\\\\d\\\\d|\\\\d)\",\n\t\ty: \"(\\\\d{2})\"\n\t},\n\n\tpad: function pad(number) {\n\t\treturn (\"0\" + number).slice(-2);\n\t},\n\n\t/**\n  * Parses a date(+time) string into a Date object\n  * @param {String} date the date string, e.g. 2017-02-03 14:45\n  * @param {String} givenFormat the date format, e.g. Y-m-d H:i\n  * @param {Boolean} timeless whether to reset the time of Date object\n  * @return {Date} the parsed Date object\n  */\n\tparseDate: function parseDate(date, givenFormat, timeless) {\n\t\tif (!date) return null;\n\n\t\tvar date_orig = date;\n\n\t\tif (date instanceof Date) date = new Date(date.getTime()); // create a copy\n\n\t\telse if (date.toFixed !== undefined) // timestamp\n\t\t\t\tdate = new Date(date);else {\n\t\t\t\t// date string\n\t\t\t\tvar format = givenFormat || (this.config || Flatpickr.defaultConfig).dateFormat;\n\t\t\t\tdate = String(date).trim();\n\n\t\t\t\tif (date === \"today\") {\n\t\t\t\t\tdate = new Date();\n\t\t\t\t\ttimeless = true;\n\t\t\t\t} else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone\n\t\t\t\t\tdate = new Date(date);else if (this.config && this.config.parseDate) date = this.config.parseDate(date, format);else {\n\t\t\t\t\tvar parsedDate = !this.config || !this.config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));\n\n\t\t\t\t\tvar matched = void 0;\n\n\t\t\t\t\tfor (var i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n\t\t\t\t\t\tvar token = format[i];\n\t\t\t\t\t\tvar isBackSlash = token === \"\\\\\";\n\t\t\t\t\t\tvar escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n\t\t\t\t\t\tif (this.tokenRegex[token] && !escaped) {\n\t\t\t\t\t\t\tregexStr += this.tokenRegex[token];\n\t\t\t\t\t\t\tvar match = new RegExp(regexStr).exec(date);\n\t\t\t\t\t\t\tif (match && (matched = true)) {\n\t\t\t\t\t\t\t\tparsedDate = this.revFormat[token](parsedDate, match[++matchIndex]) || parsedDate;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!isBackSlash) regexStr += \".\"; // don't really care\n\t\t\t\t\t}\n\n\t\t\t\t\tdate = matched ? parsedDate : null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif (!(date instanceof Date)) {\n\t\t\tconsole.warn(\"flatpickr: invalid date \" + date_orig);\n\t\t\tconsole.info(this.element);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.config && this.config.utc && !date.fp_isUTC) date = date.fp_toUTC();\n\n\t\tif (timeless === true) date.setHours(0, 0, 0, 0);\n\n\t\treturn date;\n\t}\n};\n\n/* istanbul ignore next */\nfunction _flatpickr(nodeList, config) {\n\tvar nodes = Array.prototype.slice.call(nodeList); // static list\n\tvar instances = [];\n\tfor (var i = 0; i < nodes.length; i++) {\n\t\ttry {\n\t\t\tnodes[i]._flatpickr = new Flatpickr(nodes[i], config || {});\n\t\t\tinstances.push(nodes[i]._flatpickr);\n\t\t} catch (e) {\n\t\t\tconsole.warn(e, e.stack);\n\t\t}\n\t}\n\n\treturn instances.length === 1 ? instances[0] : instances;\n}\n\n/* istanbul ignore next */\nif (typeof HTMLElement !== \"undefined\") {\n\t// browser env\n\tHTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {\n\t\treturn _flatpickr(this, config);\n\t};\n\n\tHTMLElement.prototype.flatpickr = function (config) {\n\t\treturn _flatpickr([this], config);\n\t};\n}\n\n/* istanbul ignore next */\nfunction flatpickr(selector, config) {\n\treturn _flatpickr(window.document.querySelectorAll(selector), config);\n}\n\n/* istanbul ignore next */\nif (typeof jQuery !== \"undefined\") {\n\tjQuery.fn.flatpickr = function (config) {\n\t\treturn _flatpickr(this, config);\n\t};\n}\n\nDate.prototype.fp_incr = function (days) {\n\treturn new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));\n};\n\nDate.prototype.fp_isUTC = false;\nDate.prototype.fp_toUTC = function () {\n\tvar newDate = new Date(this.getUTCFullYear(), this.getUTCMonth(), this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds());\n\n\tnewDate.fp_isUTC = true;\n\treturn newDate;\n};\n\nif (typeof module !== \"undefined\") module.exports = Flatpickr;","/home/travis/build/npmtest/node-npmtest-flatpickr/node_modules/flatpickr/src/flatpickr.js":"/*! flatpickr v2.5.7, @license MIT */\nfunction Flatpickr(element, config) {\n\tconst self = this;\n\n\tself._ = {};\n\tself._.afterDayAnim = afterDayAnim;\n\tself.changeMonth = changeMonth;\n\tself.changeYear = changeYear;\n\tself.clear = clear;\n\tself.close = close;\n\tself._createElement = createElement;\n\tself.destroy = destroy;\n\tself.isEnabled = isEnabled;\n\tself.jumpToDate = jumpToDate;\n\tself.open = open;\n\tself.redraw = redraw;\n\tself.set = set;\n\tself.setDate = setDate;\n\tself.toggle = toggle;\n\n\tfunction init() {\n\t\tif (element._flatpickr)\n\t\t\telement._flatpickr = undefined;\n\n\t\telement._flatpickr = self;\n\n\t\tself.element = element;\n\t\tself.instanceConfig = config || {};\n\t\tself.parseDate = Flatpickr.prototype.parseDate.bind(self);\n\t\tself.formatDate = Flatpickr.prototype.formatDate.bind(self);\n\n\t\tsetupFormats();\n\t\tparseConfig();\n\t\tsetupLocale();\n\t\tsetupInputs();\n\t\tsetupDates();\n\t\tsetupHelperFunctions();\n\n\t\tself.isOpen = false;\n\n\t\tself.isMobile = (\n\t\t\t!self.config.disableMobile &&\n\t\t\t!self.config.inline &&\n\t\t\tself.config.mode === \"single\" &&\n\t\t\t!self.config.disable.length &&\n\t\t\t!self.config.enable.length &&\n\t\t\t!self.config.weekNumbers &&\n\t\t\t/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n\t\t);\n\n\t\tif (!self.isMobile)\n\t\t\tbuild();\n\n\t\tbindEvents();\n\n\t\tif (self.selectedDates.length || self.config.noCalendar) {\n\t\t\tif (self.config.enableTime) {\n\t\t\t\tsetHoursFromDate(self.config.noCalendar\n\t\t\t\t\t? self.latestSelectedDateObj || self.config.minDate\n\t\t\t\t\t: null);\n\t\t\t}\n\t\t\tupdateValue();\n\t\t}\n\n\t\tif (self.config.weekNumbers) {\n\t\t\tself.calendarContainer.style.width = self.daysContainer.clientWidth\n\t\t\t\t+ self.weekWrapper.clientWidth + \"px\";\n\t\t}\n\n\t\tself.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;\n\n\t\tif (!self.isMobile)\n\t\t\tpositionCalendar();\n\n\t\ttriggerEvent(\"Ready\");\n\t}\n\n\t/**\n\t * Binds a function to the current flatpickr instance\n\t * @param {Function} fn the function\n\t * @return {Function} the function bound to the instance\n\t */\n\tfunction bindToInstance(fn) {\n\t\treturn fn.bind(self);\n\t}\n\n\t/**\n\t * The handler for all events targeting the time inputs\n\t * @param {Event} e the event - \"input\", \"wheel\", \"increment\", etc\n\t */\n\tfunction updateTime(e) {\n\t\tif (self.config.noCalendar && !self.selectedDates.length)\n\t\t\t// picking time only\n\t\t\tself.selectedDates = [self.now];\n\n\t\ttimeWrapper(e);\n\n\t\tif (!self.selectedDates.length)\n\t\t\treturn;\n\n\t\tif (!self.minDateHasTime || e.type !== \"input\" || e.target.value.length >= 2) {\n\t\t\tsetHoursFromInputs();\n\t\t\tupdateValue();\n\t\t}\n\n\t\telse {\n\t\t\tsetTimeout(function(){\n\t\t\t\tsetHoursFromInputs();\n\t\t\t\tupdateValue();\n\t\t\t}, 1000);\n\t\t}\n\t}\n\n\t/**\n\t * Syncs the selected date object time with user's time input\n\t */\n\tfunction setHoursFromInputs(){\n\t\tif (!self.config.enableTime)\n\t\t\treturn;\n\n\t\tlet hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),\n\t\t\tminutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,\n\t\t\tseconds = self.config.enableSeconds\n\t\t\t\t? (parseInt(self.secondElement.value, 10) || 0)\n\t\t\t\t: 0;\n\n\t\tif (self.amPM)\n\t\t\thours = (hours % 12) + (12 * (self.amPM.textContent === \"PM\"));\n\n\t\tif (\n\t\t\tself.minDateHasTime\n\t\t\t&& compareDates(self.latestSelectedDateObj, self.config.minDate) === 0\n\t\t) {\n\n\t\t\thours = Math.max(hours, self.config.minDate.getHours());\n\t\t\tif (hours === self.config.minDate.getHours())\n\t\t\t\tminutes = Math.max(minutes, self.config.minDate.getMinutes());\n\t\t}\n\n\t\tif (\n\t\t\tself.maxDateHasTime\n\t\t\t&& compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0\n\t\t) {\n\t\t\thours = Math.min(hours, self.config.maxDate.getHours());\n\t\t\tif (hours === self.config.maxDate.getHours())\n\t\t\t\tminutes = Math.min(minutes, self.config.maxDate.getMinutes());\n\t\t}\n\n\t\tsetHours(hours, minutes, seconds);\n\t}\n\n\t/**\n\t * Syncs time input values with a date\n\t * @param {Date} dateObj the date to sync with\n\t */\n\tfunction setHoursFromDate(dateObj){\n\t\tconst date = dateObj || self.latestSelectedDateObj;\n\n\t\tif (date)\n\t\t\tsetHours(date.getHours(), date.getMinutes(), date.getSeconds());\n\t}\n\n\t/**\n\t * Sets the hours, minutes, and optionally seconds\n\t * of the latest selected date object and the\n\t * corresponding time inputs\n\t * @param {Number} hours the hour. whether its military\n\t *                 or am-pm gets inferred from config\n\t * @param {Number} minutes the minutes\n\t * @param {Number} seconds the seconds (optional)\n\t */\n\tfunction setHours(hours, minutes, seconds) {\n\t\tif (self.selectedDates.length) {\n\t\t\tself.latestSelectedDateObj.setHours(\n\t\t\t\thours % 24, minutes, seconds || 0, 0\n\t\t\t);\n\t\t}\n\n\t\tif (!self.config.enableTime || self.isMobile)\n\t\t\treturn;\n\n\t\tself.hourElement.value = self.pad(\n\t\t\t!self.config.time_24hr\n\t\t\t\t? (12 + hours) % 12 + 12 * (hours % 12 === 0)\n\t\t\t\t: hours\n\t\t);\n\n\t\tself.minuteElement.value = self.pad(minutes);\n\n\t\tif (!self.config.time_24hr)\n\t\t\tself.amPM.textContent = hours >= 12 ? \"PM\" : \"AM\";\n\n\t\tif (self.config.enableSeconds === true)\n\t\t\tself.secondElement.value = self.pad(seconds);\n\t}\n\n\t/**\n\t * Handles the year input and incrementing events\n\t * @param {Event} event the keyup or increment event\n\t */\n\tfunction onYearInput(event) {\n\t\tlet year = event.target.value;\n\t\tif (event.delta)\n\t\t\tyear = (parseInt(year) + event.delta).toString();\n\n\t\tif (year.length === 4 || event.key === \"Enter\") {\n\t\t\tself.currentYearElement.blur();\n\t\t\tif (!/[^\\d]/.test(year))\n\t\t\t\tchangeYear(year);\n\t\t}\n\t}\n\n\t/**\n\t * Essentially addEventListener + tracking\n\t * @param {Element} element the element to addEventListener to\n\t * @param {String} event the event name\n\t * @param {Function} handler the event handler\n\t */\n\tfunction bind(element, event, handler) {\n\t\tif (event instanceof Array)\n\t\t\treturn event.forEach(ev => bind(element, ev, handler));\n\n\t\telement.addEventListener(event, handler);\n\t\tself._handlers.push({element, event, handler});\n\t}\n\n\t/**\n\t * A mousedown handler which mimics click.\n\t * Minimizes latency, since we don't need to wait for mouseup in most cases.\n\t * Also, avoids handling right clicks.\n\t *\n\t * @param {Function} handler the event handler\n\t */\n\tfunction onClick(handler) {\n\t\treturn evt => evt.which === 1 && (handler(evt));\n\t}\n\n\t/**\n\t * Adds all the necessary event listeners\n\t */\n\tfunction bindEvents() {\n\t\tself._handlers = [];\n\t\tif (self.config.wrap) {\n\t\t\t[\"open\", \"close\", \"toggle\", \"clear\"].forEach(evt => {\n\t\t\t\tArray.prototype.forEach.call(\n\t\t\t\t\tself.element.querySelectorAll(`[data-${evt}]`),\n\t\t\t\t\tel => bind(el, \"mousedown\", onClick(self[evt]))\n\t\t\t\t)\n\t\t\t});\n\t\t}\n\n\t\tif (self.isMobile)\n\t\t\treturn setupMobile();\n\n\t\tself.debouncedResize = debounce(onResize, 50);\n\t\tself.triggerChange = () => {\n\t\t\ttriggerEvent(\"Change\");\n\t\t};\n\t\tself.debouncedChange = debounce(self.triggerChange, 300);\n\n\t\tif (self.config.mode === \"range\" && self.daysContainer)\n\t\t\tbind(self.daysContainer, \"mouseover\", e => onMouseOver(e.target));\n\n\t\tbind(window.document.body, \"keydown\", onKeyDown);\n\n\t\tif (!self.config.static)\n\t\t\tbind(self._input, \"keydown\", onKeyDown);\n\n\t\tif (!self.config.inline && !self.config.static)\n\t\t\tbind(window, \"resize\", self.debouncedResize);\n\n\t\tif (window.ontouchstart)\n\t\t\tbind(window.document, \"touchstart\", documentClick);\n\n\t\tbind(window.document, \"mousedown\", onClick(documentClick));\n\t\tbind(self._input, \"blur\", documentClick);\n\n\t\tif (self.config.clickOpens)\n\t\t\tbind(self._input, \"focus\", open);\n\n\t\tif (!self.config.noCalendar) {\n\t\t\tbind(self.prevMonthNav, \"mousedown\", onClick(() => changeMonth(-1)));\n\t\t\tbind(self.nextMonthNav, \"mousedown\", onClick(() => changeMonth(1)));\n\n\t\t\tself.monthNav.addEventListener(\"wheel\", e => e.preventDefault());\n\n\t\t\tbind(self.monthNav, \"wheel\", debounce(onMonthNavScroll, 10));\n\t\t\tbind(self.monthNav, \"mousedown\", onClick(onMonthNavClick));\n\n\t\t\tbind(self.monthNav, \"mousedown\", onClick(e => {\n\t\t\t\te.preventDefault();\n\t\t\t\tif (e.target === self.currentYearElement)\n\t\t\t\t\tself.currentYearElement.select();\n\t\t\t}));\n\n\t\t\tbind(self.monthNav, [\"keyup\", \"increment\"], onYearInput);\n\n\t\t\tbind(self.daysContainer, \"mousedown\", onClick(selectDate));\n\n\t\t\tif (self.config.animate) {\n\t\t\t\tbind(self.daysContainer, [\"webkitAnimationEnd\",\"animationend\"], animateDays);\n\t\t\t\tbind(self.monthNav, [\"webkitAnimationEnd\",\"animationend\"], animateMonths);\n\t\t\t}\n\t\t}\n\n\t\tif (self.config.enableTime) {\n\t\t\tbind(self.timeContainer, [\"wheel\",  \"input\", \"increment\"], updateTime);\n\t\t\tbind(self.timeContainer, \"mousedown\", onClick(timeIncrement));\n\n\t\t\tbind(self.timeContainer, [\"wheel\", \"increment\"], self.debouncedChange);\n\t\t\tbind(self.timeContainer, \"input\", self.triggerChange);\n\n\t\t\tbind(self.hourElement, \"focus\", () => self.hourElement.select());\n\t\t\tbind(self.minuteElement, \"focus\", () => self.minuteElement.select());\n\n\t\t\tif (self.secondElement)\n\t\t\t\tbind(self.secondElement, \"focus\", () => self.secondElement.select());\n\n\t\t\tif (self.amPM) {\n\t\t\t\tbind(self.amPM, \"mousedown\", onClick(e => {\n\t\t\t\t\tupdateTime(e);\n\t\t\t\t\tself.triggerChange(e);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the day container that slided out of view\n\t * @param {Event} e the animation event\n\t */\n\tfunction animateDays (e) {\n\t\tif (self.daysContainer.childNodes.length > 1) {\n\t\t\tswitch(e.animationName) {\n\t\t\t\tcase \"slideLeft\":\n\t\t\t\t\tself.daysContainer.lastChild.classList.remove(\"slideLeftNew\")\n\t\t\t\t\tself.daysContainer.removeChild(self.daysContainer.firstChild);\n\t\t\t\t\tself.days = self.daysContainer.firstChild;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"slideRight\":\n\t\t\t\t\tself.daysContainer.firstChild.classList.remove(\"slideRightNew\")\n\t\t\t\t\tself.daysContainer.removeChild(self.daysContainer.lastChild);\n\t\t\t\t\tself.days = self.daysContainer.firstChild;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the month element that animated out of view\n\t * @param {Event} e the animation event\n\t */\n\tfunction animateMonths(e){\n\t\tswitch(e.animationName) {\n\t\t\tcase \"slideLeftNew\":\n\t\t\tcase \"slideRightNew\":\n\t\t\t\tself.navigationCurrentMonth.classList.remove(\"slideLeftNew\");\n\t\t\t\tself.navigationCurrentMonth.classList.remove(\"slideRightNew\");\n\t\t\t\tconst nav = self.navigationCurrentMonth;\n\n\t\t\t\twhile (nav.nextSibling && /curr/.test(nav.nextSibling.className))\n\t\t\t\t\tself.monthNav.removeChild(nav.nextSibling);\n\n\t\t\t\twhile (nav.previousSibling && /curr/.test(nav.previousSibling.className))\n\t\t\t\t\tself.monthNav.removeChild(nav.previousSibling);\n\n\t\t\t\tself.oldCurMonth = null;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Set the calendar view to a particular date.\n\t * @param {Date} jumpDate the date to set the view to\n\t */\n\tfunction jumpToDate(jumpDate) {\n\t\tjumpDate = jumpDate\n\t\t\t? self.parseDate(jumpDate)\n\t\t\t: self.latestSelectedDateObj || (self.config.minDate > self.now\n\t\t\t\t? self.config.minDate\n\t\t\t\t: self.config.maxDate && self.config.maxDate < self.now\n\t\t\t\t\t? self.config.maxDate\n\t\t\t\t\t: self.now\n\t\t\t);\n\n\t\ttry {\n\t\t\tself.currentYear = jumpDate.getFullYear();\n\t\t\tself.currentMonth = jumpDate.getMonth();\n\t\t}\n\n\t\tcatch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e.stack);\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.warn(\"Invalid date supplied: \" + jumpDate);\n\t\t}\n\n\t\tself.redraw();\n\t}\n\n\t/**\n\t * The up/down arrow handler for time inputs\n\t * @param {Event} e the click event\n\t */\n\tfunction timeIncrement(e) {\n\t\tif (~e.target.className.indexOf(\"arrow\"))\n\t\t\tincrementNumInput(e, e.target.classList.contains(\"arrowUp\") ? 1 : -1);\n\t}\n\n\t/**\n\t * Increments/decrements the value of input associ-\n\t * ated with the up/down arrow by dispatching an\n\t * \"increment\" event on the input.\n\t *\n\t * @param {Event} e the click event\n\t * @param {Number} delta the diff (usually 1 or -1)\n\t * @param {Element} inputElem the input element\n\t */\n\tfunction incrementNumInput(e, delta, inputElem) {\n\t\tconst input = inputElem || e.target.parentNode.childNodes[0];\n\t\tconst event = createEvent(\"increment\");\n\t\tevent.delta = delta;\n\t\tinput.dispatchEvent(event);\n\t}\n\n\tfunction createNumberInput(inputClassName) {\n\t\tconst wrapper = createElement(\"div\", \"numInputWrapper\"),\n\t\t\tnumInput = createElement(\"input\", \"numInput \" + inputClassName),\n\t\t\tarrowUp = createElement(\"span\", \"arrowUp\"),\n\t\t\tarrowDown = createElement(\"span\", \"arrowDown\");\n\n\t\tnumInput.type = \"text\";\n\t\tnumInput.pattern = \"\\\\d*\";\n\n\t\twrapper.appendChild(numInput);\n\t\twrapper.appendChild(arrowUp);\n\t\twrapper.appendChild(arrowDown);\n\n\t\treturn wrapper;\n\t}\n\n\tfunction build() {\n\t\tconst fragment = window.document.createDocumentFragment();\n\t\tself.calendarContainer = createElement(\"div\", \"flatpickr-calendar\");\n\t\tself.calendarContainer.tabIndex = -1;\n\n\t\tif (!self.config.noCalendar) {\n\t\t\tfragment.appendChild(buildMonthNav());\n\t\t\tself.innerContainer = createElement(\"div\", \"flatpickr-innerContainer\")\n\n\t\t\tif (self.config.weekNumbers)\n\t\t\t\tself.innerContainer.appendChild(buildWeeks());\n\n\t\t\tself.rContainer = createElement(\"div\", \"flatpickr-rContainer\");\n\t\t\tself.rContainer.appendChild(buildWeekdays());\n\n\t\t\tif (!self.daysContainer) {\n\t\t\t\tself.daysContainer = createElement(\"div\", \"flatpickr-days\");\n\t\t\t\tself.daysContainer.tabIndex = -1;\n\t\t\t}\n\n\t\t\tbuildDays();\n\t\t\tself.rContainer.appendChild(self.daysContainer);\n\n\t\t\tself.innerContainer.appendChild(self.rContainer);\n\t\t\tfragment.appendChild(self.innerContainer);\n\t\t}\n\n\t\tif (self.config.enableTime)\n\t\t\tfragment.appendChild(buildTime());\n\n\t\ttoggleClass(self.calendarContainer, \"rangeMode\", self.config.mode === \"range\");\n\t\ttoggleClass(self.calendarContainer, \"animate\", self.config.animate);\n\n\t\tself.calendarContainer.appendChild(fragment);\n\n\t\tconst customAppend = self.config.appendTo && self.config.appendTo.nodeType;\n\n\t\tif (self.config.inline || self.config.static) {\n\t\t\tself.calendarContainer.classList.add(self.config.inline ? \"inline\" : \"static\");\n\n\n\t\t\tif (self.config.inline && !customAppend) {\n\t\t\t\treturn self.element.parentNode.insertBefore(\n\t\t\t\t\tself.calendarContainer,\n\t\t\t\t\tself._input.nextSibling\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (self.config.static){\n\t\t\t\tconst wrapper = createElement(\"div\", \"flatpickr-wrapper\");\n\t\t\t\tself.element.parentNode.insertBefore(wrapper, self.element);\n\t\t\t\twrapper.appendChild(self.element);\n\n\t\t\t\tif(self.altInput)\n\t\t\t\t\twrapper.appendChild(self.altInput);\n\n\t\t\t\twrapper.appendChild(self.calendarContainer);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t(customAppend ? self.config.appendTo : window.document.body)\n\t\t\t.appendChild(self.calendarContainer);\n\t}\n\n\tfunction createDay(className, date, dayNumber, i) {\n\t\tconst dateIsEnabled = isEnabled(date, true),\n\t\t\tdayElement = createElement(\n\t\t\t\t\"span\",\n\t\t\t\t\"flatpickr-day \" + className,\n\t\t\t\tdate.getDate()\n\t\t\t);\n\n\t\tdayElement.dateObj = date;\n\t\tdayElement.$i = i;\n\t\tdayElement.setAttribute(\"aria-label\", self.formatDate(date, \"F j, Y\"));\n\n\t\tif (compareDates(date, self.now) === 0) {\n\t\t\tself.todayDateElem = dayElement;\n\t\t\tdayElement.classList.add(\"today\");\n\t\t}\n\n\t\tif (dateIsEnabled) {\n\t\t\tdayElement.tabIndex = -1;\n\t\t\tif (isDateSelected(date)){\n\t\t\t\tdayElement.classList.add(\"selected\");\n\t\t\t\tself.selectedDateElem = dayElement;\n\t\t\t\tif (self.config.mode === \"range\") {\n\t\t\t\t\ttoggleClass(\n\t\t\t\t\t\tdayElement,\n\t\t\t\t\t\t\"startRange\",\n\t\t\t\t\t\tcompareDates(date, self.selectedDates[0]) === 0\n\t\t\t\t\t);\n\n\t\t\t\t\ttoggleClass(\n\t\t\t\t\t\tdayElement,\n\t\t\t\t\t\t\"endRange\",\n\t\t\t\t\t\tcompareDates(date, self.selectedDates[1]) === 0\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tdayElement.classList.add(\"disabled\");\n\t\t\tif (\n\t\t\t\tself.selectedDates[0]\n\t\t\t\t&& date > self.minRangeDate\n\t\t\t\t&& date < self.selectedDates[0]\n\t\t\t)\n\n\t\t\t\tself.minRangeDate = date;\n\n\t\t\telse if (\n\t\t\t\tself.selectedDates[0]\n\t\t\t\t&& date < self.maxRangeDate\n\t\t\t\t&& date > self.selectedDates[0]\n\t\t\t)\n\t\t\t\tself.maxRangeDate = date;\n\t\t}\n\n\t\tif (self.config.mode === \"range\") {\n\t\t\tif (isDateInRange(date) && !isDateSelected(date))\n\t\t\t\tdayElement.classList.add(\"inRange\");\n\n\t\t\tif (\n\t\t\t\tself.selectedDates.length === 1 &&\n\t\t\t\t(date < self.minRangeDate || date > self.maxRangeDate)\n\t\t\t)\n\t\t\t\tdayElement.classList.add(\"notAllowed\");\n\t\t}\n\n\t\tif (self.config.weekNumbers && className !== \"prevMonthDay\" && dayNumber % 7 === 1) {\n\t\t\tself.weekNumbers.insertAdjacentHTML(\n\t\t\t\t\"beforeend\",\n\t\t\t\t\"<span class='disabled flatpickr-day'>\" + self.config.getWeek(date) + \"</span>\"\n\t\t\t);\n\t\t}\n\n\t\ttriggerEvent(\"DayCreate\", dayElement);\n\n\t\treturn dayElement;\n\t}\n\n\tfunction focusOnDay(currentIndex, offset) {\n\t\tlet newIndex = currentIndex + offset || 0,\n\t\t\ttargetNode = currentIndex !== undefined\n\t\t\t\t? self.days.childNodes[newIndex]\n\t\t\t\t: self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],\n\t\t\tfocus = () => {\n\t\t\t\ttargetNode = targetNode || self.days.childNodes[newIndex];\n\t\t\t\ttargetNode.focus();\n\n\t\t\t\tif (self.config.mode === \"range\")\n\t\t\t\t\tonMouseOver(targetNode);\n\t\t\t};\n\n\t\tif (targetNode === undefined && offset !== 0) {\n\t\t\tif (offset > 0) {\n\t\t\t\tself.changeMonth(1);\n\t\t\t\tnewIndex = newIndex % 42;\n\t\t\t}\n\n\t\t\telse if (offset < 0) {\n\t\t\t\tself.changeMonth(-1);\n\t\t\t\tnewIndex += 42;\n\t\t\t}\n\n\t\t\treturn afterDayAnim(focus);\n\t\t}\n\n\t\tfocus();\n\t}\n\n\tfunction afterDayAnim(fn) {\n\t\tif (self.config.animate)\n\t\t\treturn setTimeout(fn, self._.daysAnimDuration + 1);\n\t\tfn();\n\t}\n\n\tfunction buildDays(delta) {\n\t\tconst firstOfMonth = (\n\t\t\t\tnew Date(self.currentYear, self.currentMonth, 1).getDay() -\n\t\t\t\tself.l10n.firstDayOfWeek + 7\n\t\t\t) % 7,\n\t\t\tisRangeMode = self.config.mode === \"range\";\n\n\t\tself.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);\n\t\tself.selectedDateElem = undefined;\n\t\tself.todayDateElem = undefined;\n\n\t\tconst daysInMonth = self.utils.getDaysinMonth(),\n\t\t\tdays = window.document.createDocumentFragment();\n\n\t\tlet\tdayNumber = self.prevMonthDays + 1 - firstOfMonth,\n\t\t\tdayIndex = 0;\n\n\t\tif (self.config.weekNumbers && self.weekNumbers.firstChild)\n\t\t\tself.weekNumbers.textContent = \"\";\n\n\t\tif (isRangeMode) {\n\t\t\t// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;\n\t\t\tself.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);\n\t\t\tself.maxRangeDate = new Date(\n\t\t\t\tself.currentYear,\n\t\t\t\tself.currentMonth + 1,\n\t\t\t\t(42 - firstOfMonth) % daysInMonth\n\t\t\t);\n\t\t}\n\n\t\t// prepend days from the ending of previous month\n\t\tfor (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {\n\t\t\tdays.appendChild(\n\t\t\t\tcreateDay(\n\t\t\t\t\t\"prevMonthDay\",\n\t\t\t\t\tnew Date(self.currentYear, self.currentMonth - 1, dayNumber),\n\t\t\t\t\tdayNumber,\n\t\t\t\t\tdayIndex\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Start at 1 since there is no 0th day\n\t\tfor (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {\n\t\t\tdays.appendChild(\n\t\t\t\tcreateDay(\n\t\t\t\t\t\"\",\n\t\t\t\t\tnew Date(self.currentYear, self.currentMonth, dayNumber),\n\t\t\t\t\tdayNumber,\n\t\t\t\t\tdayIndex\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// append days from the next month\n\t\tfor (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {\n\t\t\tdays.appendChild(\n\t\t\t\tcreateDay(\n\t\t\t\t\t\"nextMonthDay\",\n\t\t\t\t\tnew Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth),\n\t\t\t\t\tdayNum,\n\t\t\t\t\tdayIndex\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {\n\t\t\tself._hidePrevMonthArrow = self._hidePrevMonthArrow ||\n\t\t\t\tself.minRangeDate > days.childNodes[0].dateObj;\n\n\t\t\tself._hideNextMonthArrow = self._hideNextMonthArrow ||\n\t\t\t\tself.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n\t\t}\n\n\t\telse\n\t\t\tupdateNavigationCurrentMonth();\n\n\t\tconst dayContainer = createElement(\"div\", \"dayContainer\");\n\t\tdayContainer.appendChild(days);\n\n\t\tif (!self.config.animate || delta === undefined)\n\t\t\tclearNode(self.daysContainer);\n\n\t\telse {\n\t\t\twhile (self.daysContainer.childNodes.length > 1)\n\t\t\t\tself.daysContainer.removeChild(self.daysContainer.firstChild);\n\t\t}\n\n\t\tif (delta >= 0)\n\t\t\tself.daysContainer.appendChild(dayContainer);\n\t\telse\n\t\t\tself.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);\n\n\t\tself.days = self.daysContainer.firstChild;\n\t\treturn self.daysContainer;\n\t}\n\n\tfunction clearNode(node) {\n\t\twhile (node.firstChild)\n\t\t\tnode.removeChild(node.firstChild);\n\t}\n\n\tfunction buildMonthNav() {\n\t\tconst monthNavFragment = window.document.createDocumentFragment();\n\t\tself.monthNav = createElement(\"div\", \"flatpickr-month\");\n\n\t\tself.prevMonthNav = createElement(\"span\", \"flatpickr-prev-month\");\n\t\tself.prevMonthNav.innerHTML = self.config.prevArrow;\n\n\t\tself.currentMonthElement = createElement(\"span\", \"cur-month\");\n\t\tself.currentMonthElement.title = self.l10n.scrollTitle;\n\n\t\tconst yearInput = createNumberInput(\"cur-year\");\n\t\tself.currentYearElement =  yearInput.childNodes[0];\n\t\tself.currentYearElement.title = self.l10n.scrollTitle;\n\n\t\tif (self.config.minDate)\n\t\t\tself.currentYearElement.min = self.config.minDate.getFullYear();\n\n\t\tif (self.config.maxDate) {\n\t\t\tself.currentYearElement.max = self.config.maxDate.getFullYear();\n\n\t\t\tself.currentYearElement.disabled = self.config.minDate\t&&\n\t\t\t\tself.config.minDate.getFullYear() === self.config.maxDate.getFullYear();\n\t\t}\n\n\t\tself.nextMonthNav = createElement(\"span\", \"flatpickr-next-month\");\n\t\tself.nextMonthNav.innerHTML = self.config.nextArrow;\n\n\t\tself.navigationCurrentMonth = createElement(\"span\", \"flatpickr-current-month\");\n\t\tself.navigationCurrentMonth.appendChild(self.currentMonthElement);\n\t\tself.navigationCurrentMonth.appendChild(yearInput);\n\n\t\tmonthNavFragment.appendChild(self.prevMonthNav);\n\t\tmonthNavFragment.appendChild(self.navigationCurrentMonth);\n\t\tmonthNavFragment.appendChild(self.nextMonthNav);\n\t\tself.monthNav.appendChild(monthNavFragment);\n\n\t\tObject.defineProperty(self, \"_hidePrevMonthArrow\", {\n\t\t\tget () {\n\t\t\t\treturn this.__hidePrevMonthArrow;\n\t\t\t},\n\t\t\tset (bool) {\n\t\t\t\tif (this.__hidePrevMonthArrow !== bool)\n\t\t\t\t\tself.prevMonthNav.style.display = bool ? \"none\" : \"block\";\n\t\t\t\tthis.__hidePrevMonthArrow = bool;\n\t\t\t}\n\t\t});\n\n\t\tObject.defineProperty(self, \"_hideNextMonthArrow\", {\n\t\t\tget () {\n\t\t\t\treturn this.__hideNextMonthArrow;\n\t\t\t},\n\t\t\tset (bool) {\n\t\t\t\tif (this.__hideNextMonthArrow !== bool)\n\t\t\t\t\tself.nextMonthNav.style.display = bool ? \"none\" : \"block\";\n\t\t\t\tthis.__hideNextMonthArrow = bool;\n\t\t\t}\n\t\t});\n\n\t\tupdateNavigationCurrentMonth();\n\n\t\treturn self.monthNav;\n\t}\n\n\tfunction buildTime() {\n\t\tself.calendarContainer.classList.add(\"hasTime\");\n\t\tif (self.config.noCalendar)\n\t\t\tself.calendarContainer.classList.add(\"noCalendar\");\n\t\tself.timeContainer = createElement(\"div\", \"flatpickr-time\");\n\t\tself.timeContainer.tabIndex = -1;\n\t\tconst separator = createElement(\"span\", \"flatpickr-time-separator\", \":\");\n\n\t\tconst hourInput = createNumberInput(\"flatpickr-hour\");\n\t\tself.hourElement =  hourInput.childNodes[0];\n\n\t\tconst minuteInput = createNumberInput(\"flatpickr-minute\");\n\t\tself.minuteElement =  minuteInput.childNodes[0];\n\n\t\tself.hourElement.tabIndex = self.minuteElement.tabIndex = -1;\n\n\t\tself.hourElement.value = self.pad(self.latestSelectedDateObj\n\t\t\t? self.latestSelectedDateObj.getHours()\n\t\t\t: self.config.defaultHour\n\t\t);\n\n\t\tself.minuteElement.value = self.pad(self.latestSelectedDateObj\n\t\t\t? self.latestSelectedDateObj.getMinutes()\n\t\t\t: self.config.defaultMinute\n\t\t);\n\n\t\tself.hourElement.step = self.config.hourIncrement;\n\t\tself.minuteElement.step = self.config.minuteIncrement;\n\n\t\tself.hourElement.min = self.config.time_24hr ? 0 : 1;\n\t\tself.hourElement.max = self.config.time_24hr ? 23 : 12;\n\n\t\tself.minuteElement.min = 0;\n\t\tself.minuteElement.max = 59;\n\n\t\tself.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;\n\n\t\tself.timeContainer.appendChild(hourInput);\n\t\tself.timeContainer.appendChild(separator);\n\t\tself.timeContainer.appendChild(minuteInput);\n\n\t\tif (self.config.time_24hr)\n\t\t\tself.timeContainer.classList.add(\"time24hr\");\n\n\t\tif (self.config.enableSeconds) {\n\t\t\tself.timeContainer.classList.add(\"hasSeconds\");\n\n\t\t\tconst secondInput = createNumberInput(\"flatpickr-second\");\n\t\t\tself.secondElement =  secondInput.childNodes[0];\n\n\t\t\tself.secondElement.value =\n\t\t\t\tself.latestSelectedDateObj ? self.pad(self.latestSelectedDateObj.getSeconds()) : \"00\";\n\n\t\t\tself.secondElement.step = self.minuteElement.step;\n\t\t\tself.secondElement.min = self.minuteElement.min;\n\t\t\tself.secondElement.max = self.minuteElement.max;\n\n\t\t\tself.timeContainer.appendChild(\n\t\t\t\tcreateElement(\"span\", \"flatpickr-time-separator\", \":\")\n\t\t\t);\n\t\t\tself.timeContainer.appendChild(secondInput);\n\t\t}\n\n\t\tif (!self.config.time_24hr) { // add self.amPM if appropriate\n\t\t\tself.amPM = createElement(\n\t\t\t\t\"span\",\n\t\t\t\t\"flatpickr-am-pm\",\n\t\t\t\t[\"AM\", \"PM\"][(self.hourElement.value > 11) | 0]\n\t\t\t);\n\t\t\tself.amPM.title = self.l10n.toggleTitle;\n\t\t\tself.amPM.tabIndex = -1;\n\t\t\tself.timeContainer.appendChild(self.amPM);\n\t\t}\n\n\t\treturn self.timeContainer;\n\t}\n\n\tfunction buildWeekdays() {\n\t\tif (!self.weekdayContainer)\n\t\t\tself.weekdayContainer = createElement(\"div\", \"flatpickr-weekdays\");\n\n\t\tconst firstDayOfWeek = self.l10n.firstDayOfWeek;\n\t\tlet\tweekdays = self.l10n.weekdays.shorthand.slice();\n\n\t\tif (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {\n\t\t\tweekdays = [].concat(\n\t\t\t\tweekdays.splice(firstDayOfWeek, weekdays.length),\n\t\t\t\tweekdays.splice(0, firstDayOfWeek)\n\t\t\t);\n\t\t}\n\n\t\tself.weekdayContainer.innerHTML = `\n\t\t<span class=flatpickr-weekday>\n\t\t\t${weekdays.join(\"</span><span class=flatpickr-weekday>\")}\n\t\t</span>\n\t\t`;\n\n\t\treturn self.weekdayContainer;\n\t}\n\n\t/* istanbul ignore next */\n\tfunction buildWeeks() {\n\t\tself.calendarContainer.classList.add(\"hasWeeks\");\n\t\tself.weekWrapper = createElement(\"div\", \"flatpickr-weekwrapper\");\n\t\tself.weekWrapper.appendChild(\n\t\t\tcreateElement(\"span\", \"flatpickr-weekday\", self.l10n.weekAbbreviation)\n\t\t);\n\t\tself.weekNumbers = createElement(\"div\", \"flatpickr-weeks\");\n\t\tself.weekWrapper.appendChild(self.weekNumbers);\n\n\t\treturn self.weekWrapper;\n\t}\n\n\tfunction changeMonth(value, is_offset, animate) {\n\t\tis_offset = (is_offset === undefined) || is_offset;\n\t\tconst delta = is_offset ? value : value - self.currentMonth;\n\t\tconst skipAnimations = !self.config.animate || animate === false;\n\n\t\tif (\n\t\t\t(delta < 0 && self._hidePrevMonthArrow) ||\n\t\t\t(delta > 0 && self._hideNextMonthArrow)\n\t\t)\n\t\t\treturn;\n\n\t\tself.currentMonth += delta;\n\n\t\tif (self.currentMonth < 0 || self.currentMonth > 11) {\n\t\t\tself.currentYear += (self.currentMonth > 11 ? 1 : -1);\n\t\t\tself.currentMonth = (self.currentMonth + 12) % 12;\n\n\t\t\ttriggerEvent(\"YearChange\");\n\t\t}\n\n\t\tbuildDays(!skipAnimations ? delta : undefined);\n\n\n\n\t\tif (skipAnimations) {\n\t\t\ttriggerEvent(\"MonthChange\");\n\t\t\treturn updateNavigationCurrentMonth();\n\t\t}\n\n\t\t// remove possible remnants from clicking too fast\n\t\tconst nav = self.navigationCurrentMonth;\n\t\tif(delta < 0) {\n\t\t\twhile (nav.nextSibling && /curr/.test(nav.nextSibling.className))\n\t\t\t\tself.monthNav.removeChild(nav.nextSibling);\n\t\t}\n\n\t\telse if (delta > 0) {\n\t\t\twhile (nav.previousSibling && /curr/.test(nav.previousSibling.className))\n\t\t\t\tself.monthNav.removeChild(nav.previousSibling);\n\t\t}\n\n\t\tself.oldCurMonth = self.navigationCurrentMonth;\n\n\t\tself.navigationCurrentMonth = self.monthNav.insertBefore(\n\t\t\tself.oldCurMonth.cloneNode(true),\n\t\t\tdelta > 0\n\t\t\t\t? self.oldCurMonth.nextSibling\n\t\t\t\t: self.oldCurMonth\n\t\t);\n\n\n\t\tif (delta > 0) {\n\t\t\tself.daysContainer.firstChild.classList.add(\"slideLeft\");\n\t\t\tself.daysContainer.lastChild.classList.add(\"slideLeftNew\");\n\n\t\t\tself.oldCurMonth.classList.add(\"slideLeft\");\n\t\t\tself.navigationCurrentMonth.classList.add(\"slideLeftNew\");\n\t\t}\n\n\t\telse if (delta < 0) {\n\t\t\tself.daysContainer.firstChild.classList.add(\"slideRightNew\");\n\t\t\tself.daysContainer.lastChild.classList.add(\"slideRight\");\n\n\t\t\tself.oldCurMonth.classList.add(\"slideRight\");\n\t\t\tself.navigationCurrentMonth.classList.add(\"slideRightNew\");\n\t\t}\n\n\t\tself.currentMonthElement = self.navigationCurrentMonth.firstChild;\n\t\tself.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];\n\n\t\tupdateNavigationCurrentMonth();\n\t\tself.oldCurMonth.firstChild.textContent =\n\t\t\tself.utils.monthToStr(self.currentMonth - delta)\n\n\t\tif (self._.daysAnimDuration === undefined) {\n\t\t\tconst compStyle = window.getComputedStyle(self.daysContainer.lastChild);\n\n\t\t\tconst duration = compStyle.getPropertyValue(\"animation-duration\")\n\t\t\t\t|| compStyle.getPropertyValue(\"-webkit-animation-duration\");\n\n\t\t\tself._.daysAnimDuration = parseInt(/(\\d+)s/.exec(duration)[1]);\n\t\t}\n\t}\n\n\tfunction clear(triggerChangeEvent) {\n\t\tself.input.value = \"\";\n\n\t\tif (self.altInput)\n\t\t\tself.altInput.value = \"\";\n\n\t\tif (self.mobileInput)\n\t\t\tself.mobileInput.value = \"\";\n\n\t\tself.selectedDates = [];\n\t\tself.latestSelectedDateObj = undefined;\n\t\tself.showTimeInput = false;\n\n\t\tself.redraw();\n\n\t\tif (triggerChangeEvent !== false)\n\t\t\t// triggerChangeEvent is true (default) or an Event\n\t\t\ttriggerEvent(\"Change\");\n\t}\n\n\tfunction close() {\n\t\tself.isOpen = false;\n\n\t\tif (!self.isMobile) {\n\t\t\tself.calendarContainer.classList.remove(\"open\");\n\t\t\tself._input.classList.remove(\"active\");\n\t\t}\n\n\t\ttriggerEvent(\"Close\");\n\t}\n\n\tfunction destroy(instance) {\n\t\tinstance = instance || self;\n\n\t\tfor (let i = instance._handlers.length; i--;) {\n\t\t\tconst h = instance._handlers[i];\n\t\t\th.element.removeEventListener(h.event, h.handler);\n\t\t}\n\n\t\tinstance._handlers = [];\n\n\t\tif (instance.mobileInput) {\n\t\t\tif (instance.mobileInput.parentNode)\n\t\t\t\tinstance.mobileInput.parentNode.removeChild(instance.mobileInput);\n\t\t\tinstance.mobileInput = undefined;\n\t\t}\n\n\t\telse if (instance.calendarContainer && instance.calendarContainer.parentNode)\n\t\t\tinstance.calendarContainer.parentNode.removeChild(instance.calendarContainer);\n\n\t\tif (instance.altInput) {\n\t\t\tinstance.input.type = \"text\";\n\t\t\tif (instance.altInput.parentNode)\n\t\t\t\tinstance.altInput.parentNode.removeChild(instance.altInput);\n\t\t\tinstance.altInput = undefined;\n\t\t}\n\n\t\tif (instance.input) {\n\t\t\tinstance.input.type = instance.input._type;\n\t\t\tinstance.input.classList.remove(\"flatpickr-input\");\n\t\t\tinstance.input.removeAttribute(\"readonly\");\n\t\t\tinstance.input.value = \"\";\n\t\t}\n\n\t\tinstance.config = undefined;\n\t\tinstance.input._flatpickr = undefined;\n\t}\n\n\tfunction isCalendarElem(elem) {\n\t\tif (self.config.appendTo && self.config.appendTo.contains(elem))\n\t\t\treturn true;\n\n\t\treturn self.calendarContainer.contains(elem);\n\t}\n\n\tfunction documentClick(e) {\n\t\tif (self.isOpen && !self.config.inline) {\n\t\t\tconst isCalendarElement = isCalendarElem(e.target);\n\t\t\tconst isInput = e.target === self.input\n\t\t\t\t|| e.target === self.altInput\n\t\t\t\t|| self.element.contains(e.target)\n\t\t\t\t|| (\n\t\t\t\t\t// web components\n\t\t\t\t\te.path && e.path.indexOf &&\n\t\t\t\t\t(~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput))\n\t\t\t\t);\n\n\t\t\tconst lostFocus = e.type === \"blur\"\n\t\t\t\t? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget)\n\t\t\t\t: !isInput && !isCalendarElement;\n\n\t\t\tif(lostFocus) {\n\t\t\t\te.preventDefault();\n\t\t\t\tself.close();\n\n\t\t\t\tif (self.config.mode === \"range\" && self.selectedDates.length === 1) {\n\t\t\t\t\tself.clear();\n\t\t\t\t\tself.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction changeYear(newYear) {\n\t\tif (\n\t\t\t!newYear\n\t\t\t|| (self.currentYearElement.min && newYear < self.currentYearElement.min)\n\t\t\t|| (self.currentYearElement.max && newYear > self.currentYearElement.max)\n\t\t)\n\t\t\treturn;\n\n\t\tconst newYearNum = parseInt(newYear, 10),\n\t\t\tisNewYear = self.currentYear !== newYearNum;\n\n\t\tself.currentYear = newYearNum || self.currentYear;\n\n\t\tif (self.config.maxDate\t&& self.currentYear === self.config.maxDate.getFullYear()) {\n\t\t\tself.currentMonth = Math.min(\n\t\t\t\tself.config.maxDate.getMonth(),\n\t\t\t\tself.currentMonth\n\t\t\t);\n\t\t}\n\n\t\telse if (\n\t\t\tself.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {\n\t\t\tself.currentMonth = Math.max(\n\t\t\t\tself.config.minDate.getMonth(),\n\t\t\t\tself.currentMonth\n\t\t\t);\n\t\t}\n\n\t\tif (isNewYear) {\n\t\t\tself.redraw();\n\t\t\ttriggerEvent(\"YearChange\");\n\t\t}\n\t}\n\n\tfunction isEnabled(date, timeless) {\n\t\tif (\n\t\t\t(self.config.minDate && compareDates(\n\t\t\t\tdate,\n\t\t\t\tself.config.minDate,\n\t\t\t\ttimeless !== undefined ? timeless : !self.minDateHasTime\n\t\t\t) < 0) || (self.config.maxDate && compareDates(\n\t\t\t\tdate,\n\t\t\t\tself.config.maxDate,\n\t\t\t\ttimeless !== undefined ? timeless : !self.maxDateHasTime\n\t\t\t) > 0)\n\t\t)\n\t\t\treturn false;\n\n\t\tif (!self.config.enable.length && !self.config.disable.length)\n\t\t\treturn true;\n\n\t\tconst dateToCheck = self.parseDate(date, null, true); // timeless\n\n\t\tconst bool = self.config.enable.length > 0,\n\t\t\tarray = bool ? self.config.enable : self.config.disable;\n\n\t\tfor (let i = 0, d; i < array.length; i++) {\n\t\t\td = array[i];\n\n\t\t\tif (d instanceof Function && d(dateToCheck)) // disabled by function\n\t\t\t\treturn bool;\n\n\t\t\telse if (d instanceof Date && d.getTime() === dateToCheck.getTime())\n\t\t\t\t// disabled by date\n\t\t\t\treturn bool;\n\n\t\t\telse if (typeof d === \"string\" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime())\n\t\t\t\t// disabled by date string\n\t\t\t\treturn bool;\n\n\t\t\telse if ( // disabled by range\n\t\t\t\ttypeof d === \"object\" && d.from && d.to &&\n\t\t\t\tdateToCheck >= d.from && dateToCheck <= d.to\n\t\t\t)\n\t\t\t\treturn bool;\n\t\t}\n\n\t\treturn !bool;\n\t}\n\n\tfunction onKeyDown(e) {\n\t\tconst isInput = e.target === self._input;\n\t\tconst calendarElem = isCalendarElem(e.target);\n\t\tconst allowInput = self.config.allowInput;\n\t\tconst allowKeydown = self.isOpen && (!allowInput || !isInput);\n\t\tconst allowInlineKeydown = self.config.inline && isInput && !allowInput;\n\n\t\tif (e.key === \"Enter\" && allowInput && isInput) {\n\t\t\tself.setDate(\n\t\t\t\tself._input.value,\n\t\t\t\ttrue,\n\t\t\t\te.target === self.altInput\n\t\t\t\t\t? self.config.altFormat\n\t\t\t\t\t: self.config.dateFormat\n\t\t\t);\n\t\t\treturn e.target.blur();\n\t\t}\n\n\t\telse if (calendarElem || allowKeydown || allowInlineKeydown) {\n\t\t\tconst isTimeObj = self.timeContainer\n\t\t\t\t&& self.timeContainer.contains(e.target);\n\t\t\tswitch (e.key) {\n\t\t\t\tcase \"Enter\":\n\t\t\t\t\tif (isTimeObj)\n\t\t\t\t\t\tupdateValue();\n\n\t\t\t\t\telse\n\t\t\t\t\t\tselectDate(e);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Escape\": // escape\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tself.close();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ArrowLeft\":\n\t\t\t\tcase \"ArrowRight\":\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\tif (self.daysContainer) {\n\t\t\t\t\t\tconst delta = e.key === \"ArrowRight\" ? 1 : -1;\n\n\t\t\t\t\t\tif (!e.ctrlKey)\n\t\t\t\t\t\t\tfocusOnDay(e.target.$i, delta);\n\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tchangeMonth(delta, true);\n\t\t\t\t\t\t\tafterDayAnim(() => {\n\t\t\t\t\t\t\t\tfocusOnDay(e.target.$i, 0)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (self.config.enableTime && !isTimeObj)\n\t\t\t\t\t\tself.hourElement.focus();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ArrowUp\":\n\t\t\t\tcase \"ArrowDown\":\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tconst delta = e.key === \"ArrowDown\" ? 1 : -1;\n\n\t\t\t\t\tif (self.daysContainer) {\n\t\t\t\t\t\tif (e.ctrlKey) {\n\t\t\t\t\t\t\tchangeYear(self.currentYear - delta);\n\t\t\t\t\t\t\tfocusOnDay(e.target.$i, 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telse if (!isTimeObj)\n\t\t\t\t\t\t\tfocusOnDay(e.target.$i, delta * 7);\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (self.config.enableTime) {\n\t\t\t\t\t\tif (!isTimeObj)\n\t\t\t\t\t\t\tself.hourElement.focus();\n\t\t\t\t\t\tupdateTime(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Tab\":\n\t\t\t\t\tif (e.target === self.hourElement) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tself.minuteElement.select();\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (e.target === self.minuteElement && self.amPM) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tself.amPM.focus();\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"a\":\n\t\t\t\t\tif (e.target === self.amPM) {\n\t\t\t\t\t\tself.amPM.textContent = \"AM\";\n\t\t\t\t\t\tsetHoursFromInputs();\n\t\t\t\t\t\tupdateValue();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"p\":\n\t\t\t\t\tif (e.target === self.amPM) {\n\t\t\t\t\t\tself.amPM.textContent = \"PM\";\n\t\t\t\t\t\tsetHoursFromInputs();\n\t\t\t\t\t\tupdateValue();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: break;\n\n\t\t\t}\n\n\t\t\ttriggerEvent(\"KeyDown\", e);\n\t\t}\n\t}\n\n\tfunction onMouseOver(elem) {\n\t\tif (self.selectedDates.length !== 1 || !elem.classList.contains(\"flatpickr-day\"))\n\t\t\treturn;\n\n\t\tlet hoverDate = elem.dateObj,\n\t\t\tinitialDate = self.parseDate(self.selectedDates[0], null, true),\n\t\t\trangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),\n\t\t\trangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),\n\t\t\tcontainsDisabled = false;\n\n\t\tfor (let t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {\n\t\t\tif (!isEnabled(new Date(t))) {\n\t\t\t\tcontainsDisabled = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (\n\t\t\tlet timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0;\n\t\t\ti < 42;\n\t\t\ti++, timestamp += self.utils.duration.DAY\n\t\t) {\n\t\t\tconst outOfRange = timestamp < self.minRangeDate.getTime()\n\t\t\t\t|| timestamp > self.maxRangeDate.getTime(),\n\t\t\t\tdayElem = self.days.childNodes[i];\n\n\t\t\tif (outOfRange) {\n\t\t\t\tself.days.childNodes[i].classList.add(\"notAllowed\");\n\t\t\t\t[\"inRange\", \"startRange\", \"endRange\"].forEach(c => {\n\t\t\t\t\tdayElem.classList.remove(c)\n\t\t\t\t});\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (containsDisabled && !outOfRange)\n\t\t\t\tcontinue;\n\n\t\t\t[\"startRange\", \"inRange\", \"endRange\", \"notAllowed\"].forEach(c => {\n\t\t\t\tdayElem.classList.remove(c)\n\t\t\t});\n\n\t\t\tconst minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),\n\t\t\t\tmaxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);\n\n\t\t\telem.classList.add(hoverDate < self.selectedDates[0] ? \"startRange\" : \"endRange\");\n\n\t\t\tif (initialDate < hoverDate && timestamp === initialDate.getTime())\n\t\t\t\tdayElem.classList.add(\"startRange\");\n\n\t\t\telse if (initialDate > hoverDate && timestamp === initialDate.getTime())\n\t\t\t\tdayElem.classList.add(\"endRange\");\n\n\t\t\tif (timestamp >= minRangeDate && timestamp <= maxRangeDate)\n\t\t\t\tdayElem.classList.add(\"inRange\");\n\t\t}\n\t}\n\n\tfunction onResize() {\n\t\tif (self.isOpen && !self.config.static && !self.config.inline)\n\t\t\tpositionCalendar();\n\t}\n\n\tfunction open(e) {\n\t\tif (self.isMobile) {\n\t\t\tif (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\te.target.blur();\n\t\t\t}\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tself.mobileInput.click();\n\t\t\t}, 0);\n\n\t\t\ttriggerEvent(\"Open\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (self.isOpen || self._input.disabled || self.config.inline)\n\t\t\treturn;\n\n\t\tself.isOpen = true;\n\t\tself.calendarContainer.classList.add(\"open\");\n\t\tpositionCalendar();\n\t\tself._input.classList.add(\"active\");\n\n\n\t\ttriggerEvent(\"Open\");\n\t}\n\n\tfunction minMaxDateSetter(type) {\n\t\treturn function(date) {\n\t\t\tconst dateObj = self.config[`_${type}Date`] = self.parseDate(date);\n\n\t\t\tconst inverseDateObj = self.config[`_${type === \"min\" ? \"max\" : \"min\"}Date`];\n\t\t\tconst isValidDate = date && dateObj instanceof Date;\n\n\t\t\tif (isValidDate) {\n\t\t\t\tself[`${type}DateHasTime`] = dateObj.getHours()\n\t\t\t\t\t|| dateObj.getMinutes()\n\t\t\t\t\t|| dateObj.getSeconds();\n\t\t\t}\n\n\t\t\tif (self.selectedDates) {\n\t\t\t\tself.selectedDates = self.selectedDates.filter(d => isEnabled(d));\n\t\t\t\tif (!self.selectedDates.length && type === \"min\")\n\t\t\t\t\tsetHoursFromDate(dateObj);\n\t\t\t\tupdateValue();\n\t\t\t}\n\n\t\t\tif(self.daysContainer) {\n\t\t\t\tredraw();\n\n\t\t\t\tif(isValidDate)\n\t\t\t\t\tself.currentYearElement[type] = dateObj.getFullYear();\n\t\t\t\telse\n\t\t\t\t\tself.currentYearElement.removeAttribute(type);\n\n\t\t\t\tself.currentYearElement.disabled = inverseDateObj && dateObj &&\n\t\t\t\t\tinverseDateObj.getFullYear() === dateObj.getFullYear();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseConfig() {\n\t\tlet boolOpts = [\n\t\t\t\"utc\", \"wrap\", \"weekNumbers\", \"allowInput\", \"clickOpens\", \"time_24hr\", \"enableTime\", \"noCalendar\", \"altInput\", \"shorthandCurrentMonth\", \"inline\", \"static\", \"enableSeconds\", \"disableMobile\"\n\t\t];\n\n\t\tlet hooks = [\n\t\t\t\"onChange\", \"onClose\", \"onDayCreate\", \"onKeyDown\", \"onMonthChange\",\n\t\t\t\"onOpen\", \"onParseConfig\", \"onReady\", \"onValueUpdate\", \"onYearChange\"\n\t\t];\n\n\t\tself.config = Object.create(Flatpickr.defaultConfig);\n\n\t\tlet userConfig = Object.assign(\n\t\t\t{},\n\t\t\tself.instanceConfig,\n\t\t\tJSON.parse(JSON.stringify(self.element.dataset || {}))\n\t\t);\n\n\t\tself.config.parseDate = userConfig.parseDate;\n\t\tself.config.formatDate = userConfig.formatDate;\n\n\t\tObject.assign(self.config, userConfig);\n\n\t\tif (!userConfig.dateFormat && userConfig.enableTime) {\n\t\t\tself.config.dateFormat = self.config.noCalendar\n\t\t\t\t? \"H:i\" + (self.config.enableSeconds ? \":S\" : \"\")\n\t\t\t\t: Flatpickr.defaultConfig.dateFormat + \" H:i\" + (self.config.enableSeconds ? \":S\" : \"\");\n\t\t}\n\n\t\tif (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {\n\t\t\tself.config.altFormat = self.config.noCalendar\n\t\t\t\t? \"h:i\" + (self.config.enableSeconds ? \":S K\" : \" K\")\n\t\t\t\t: Flatpickr.defaultConfig.altFormat + ` h:i${self.config.enableSeconds ? \":S\" : \"\"} K`;\n\t\t}\n\n\t\tObject.defineProperty(self.config, \"minDate\", {\n\t\t\tget: function() {\n\t\t\t\treturn this._minDate;\n\t\t\t},\n\t\t\tset: minMaxDateSetter(\"min\")\n\t\t});\n\n\t\tObject.defineProperty(self.config, \"maxDate\", {\n\t\t\tget: function() {\n\t\t\t\treturn this._maxDate;\n\t\t\t},\n\t\t\tset: minMaxDateSetter(\"max\")\n\t\t});\n\n\t\tself.config.minDate = userConfig.minDate;\n\t\tself.config.maxDate = userConfig.maxDate;\n\n\t\tfor (let i = 0; i < boolOpts.length; i++)\n\t\t\tself.config[boolOpts[i]] = (self.config[boolOpts[i]] === true) || self.config[boolOpts[i]] === \"true\";\n\n\t\tfor (let i = 0; i < hooks.length; i++)\n\t\t\tself.config[hooks[i]] = arrayify(self.config[hooks[i]] || []).map(bindToInstance);\n\n\t\tfor (let i = 0; i < self.config.plugins.length; i++) {\n\t\t\tconst pluginConf = self.config.plugins[i](self) || {};\n\t\t\tfor (let key in pluginConf) {\n\n\t\t\t\tif ((self.config[key] || ~hooks.indexOf(key)) instanceof Array) {\n\t\t\t\t\tself.config[key] = arrayify(pluginConf[key])\n\t\t\t\t\t\t.map(bindToInstance)\n\t\t\t\t\t\t.concat(self.config[key]);\n\t\t\t\t}\n\n\t\t\t\telse if (typeof userConfig[key] === \"undefined\")\n\t\t\t\t\tself.config[key] = pluginConf[key];\n\t\t\t}\n\t\t}\n\n\n\t\ttriggerEvent(\"ParseConfig\");\n\t}\n\n\tfunction setupLocale() {\n\t\tif (typeof self.config.locale !== \"object\" &&\n\t\t\ttypeof Flatpickr.l10ns[self.config.locale] === \"undefined\"\n\t\t)\n\t\t\tconsole.warn(`flatpickr: invalid locale ${self.config.locale}`);\n\n\t\tself.l10n = Object.assign(\n\t\t\tObject.create(Flatpickr.l10ns.default),\n\t\t\ttypeof self.config.locale === \"object\"\n\t\t\t\t? self.config.locale\n\t\t\t\t: self.config.locale !== \"default\"\n\t\t\t\t\t? Flatpickr.l10ns[self.config.locale] || {}\n\t\t\t\t\t: {}\n\t\t);\n\t}\n\n\tfunction positionCalendar() {\n\t\tif (self.calendarContainer === undefined)\n\t\t\treturn;\n\n\t\tconst calendarHeight = self.calendarContainer.offsetHeight,\n\t\t\tcalendarWidth = self.calendarContainer.offsetWidth,\n\t\t\tconfigPos = self.config.position,\n\t\t\tinputBounds = self._input.getBoundingClientRect(),\n\t\t\tdistanceFromBottom = window.innerHeight - inputBounds.bottom,\n\t\t\tshowOnTop = configPos === \"above\" || (\n\t\t\t\tconfigPos !== \"below\"\n\t\t\t\t&& distanceFromBottom < calendarHeight\n\t\t\t\t&& inputBounds.top > calendarHeight\n\t\t\t);\n\n\t\tlet top = (window.pageYOffset + inputBounds.top) + (!showOnTop\n\t\t\t? (self._input.offsetHeight + 2)\n\t\t\t: (- calendarHeight - 2)\n\t\t);\n\n\t\ttoggleClass(self.calendarContainer, \"arrowTop\", !showOnTop);\n\t\ttoggleClass(self.calendarContainer, \"arrowBottom\", showOnTop);\n\n\t\tif (self.config.inline)\n\t\t\treturn;\n\n\t\tconst left = window.pageXOffset + inputBounds.left;\n\t\tconst right = window.document.body.offsetWidth - inputBounds.right;\n\t\tconst rightMost = left + calendarWidth > window.document.body.offsetWidth;\n\n\t\ttoggleClass(self.calendarContainer, \"rightMost\", rightMost);\n\n\t\tif (self.config.static)\n\t\t\treturn;\n\n\t\tself.calendarContainer.style.top = `${top}px`;\n\n\t\tif (!rightMost) {\n\t\t\tself.calendarContainer.style.left = `${left}px`;\n\t\t\tself.calendarContainer.style.right = \"auto\";\n\t\t}\n\n\t\telse {\n\t\t\tself.calendarContainer.style.left = \"auto\";\n\t\t\tself.calendarContainer.style.right = `${right}px`;\n\t\t}\n\t}\n\n\tfunction redraw() {\n\t\tif (self.config.noCalendar || self.isMobile)\n\t\t\treturn;\n\n\t\tbuildWeekdays();\n\t\tupdateNavigationCurrentMonth();\n\t\tbuildDays();\n\t}\n\n\tfunction selectDate(e) {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\n\t\tif (\n\t\t\t!e.target.classList.contains(\"flatpickr-day\") ||\n\t\t\te.target.classList.contains(\"disabled\") ||\n\t\t\te.target.classList.contains(\"notAllowed\")\n\t\t)\n\t\t\treturn;\n\n\t\tconst selectedDate\n\t\t\t= self.latestSelectedDateObj\n\t\t\t= new Date(e.target.dateObj.getTime());\n\n\t\tconst shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth\n\t\t\t&& self.config.mode !== \"range\";\n\n\t\tself.selectedDateElem = e.target;\n\n\t\tif (self.config.mode === \"single\")\n\t\t\tself.selectedDates = [selectedDate];\n\n\t\telse if (self.config.mode === \"multiple\") {\n\t\t\tconst selectedIndex = isDateSelected(selectedDate);\n\t\t\tif (selectedIndex)\n\t\t\t\tself.selectedDates.splice(selectedIndex, 1);\n\n\t\t\telse\n\t\t\t\tself.selectedDates.push(selectedDate);\n\t\t}\n\n\t\telse if (self.config.mode === \"range\") {\n\t\t\tif (self.selectedDates.length === 2)\n\t\t\t\tself.clear();\n\n\t\t\tself.selectedDates.push(selectedDate);\n\n\t\t\t// unless selecting same date twice, sort ascendingly\n\t\t\tif (compareDates(selectedDate, self.selectedDates[0], true) !== 0)\n\t\t\t\tself.selectedDates.sort((a,b) => a.getTime() - b.getTime());\n\t\t}\n\n\t\tsetHoursFromInputs();\n\n\t\tif (shouldChangeMonth) {\n\t\t\tconst isNewYear = self.currentYear !== selectedDate.getFullYear();\n\t\t\tself.currentYear = selectedDate.getFullYear();\n\t\t\tself.currentMonth = selectedDate.getMonth();\n\n\t\t\tif (isNewYear)\n\t\t\t\ttriggerEvent(\"YearChange\");\n\n\t\t\ttriggerEvent(\"MonthChange\");\n\t\t}\n\n\t\tbuildDays();\n\n\t\tif (self.minDateHasTime\t&& self.config.enableTime\n\t\t\t&& compareDates(selectedDate, self.config.minDate) === 0\n\t\t)\n\t\t\tsetHoursFromDate(self.config.minDate);\n\n\t\tupdateValue();\n\n\t\tif (self.config.enableTime)\n\t\t\tsetTimeout(() => self.showTimeInput = true, 50);\n\n\t\tif (self.config.mode === \"range\") {\n\t\t\tif(self.selectedDates.length === 1) {\n\t\t\t\tonMouseOver(e.target);\n\n\t\t\t\tself._hidePrevMonthArrow = self._hidePrevMonthArrow ||\n\t\t\t\t\tself.minRangeDate > self.days.childNodes[0].dateObj;\n\n\t\t\t\tself._hideNextMonthArrow = self._hideNextMonthArrow ||\n\t\t\t\t\tself.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tupdateNavigationCurrentMonth();\n\t\t\t\tself.close();\n\t\t\t}\n\t\t}\n\n\t\ttriggerEvent(\"Change\");\n\n\t\t// maintain focus\n\t\tif (!shouldChangeMonth)\n\t\t\tfocusOnDay(e.target.$i, 0);\n\t\telse\n\t\t\tafterDayAnim(() => self.selectedDateElem.focus());\n\n\t\tif (self.config.enableTime)\n\t\t\tsetTimeout(() => self.hourElement.select(), 451);\n\n\t\tif (self.config.mode === \"single\" && !self.config.enableTime)\n\t\t\tself.close();\n\t}\n\n\tfunction set(option, value) {\n\t\tself.config[option] = value;\n\t\tself.redraw();\n\t\tjumpToDate();\n\t}\n\n\tfunction setSelectedDate(inputDate, format) {\n\t\tif (inputDate instanceof Array)\n\t\t\tself.selectedDates = inputDate.map(d => self.parseDate(d, format));\n\n\t\telse if (inputDate instanceof Date || !isNaN(inputDate))\n\t\t\tself.selectedDates = [self.parseDate(inputDate, format)];\n\n\t\telse if (inputDate && inputDate.substring) {\n\t\t\tswitch (self.config.mode) {\n\t\t\t\tcase \"single\":\n\t\t\t\t\tself.selectedDates = [self.parseDate(inputDate, format)];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"multiple\":\n\t\t\t\t\tself.selectedDates = inputDate\n\t\t\t\t\t\t.split(\"; \")\n\t\t\t\t\t\t.map(date => self.parseDate(date, format));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"range\":\n\t\t\t\t\tself.selectedDates = inputDate\n\t\t\t\t\t\t.split(self.l10n.rangeSeparator)\n\t\t\t\t\t\t.map(date => self.parseDate(date, format));\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: break;\n\t\t\t}\n\t\t}\n\n\t\tself.selectedDates = self.selectedDates.filter(\n\t\t\td => d instanceof Date && isEnabled(d, false)\n\t\t);\n\n\t\tself.selectedDates.sort((a,b) => a.getTime() - b.getTime());\n\t}\n\n\tfunction setDate(date, triggerChange, format) {\n\t\tif (!date)\n\t\t\treturn self.clear(triggerChange);\n\n\t\tsetSelectedDate(date, format);\n\n\t\tself.showTimeInput = self.selectedDates.length > 0;\n\t\tself.latestSelectedDateObj = self.selectedDates[0];\n\n\t\tself.redraw();\n\t\tjumpToDate();\n\n\t\tsetHoursFromDate();\n\t\tupdateValue();\n\n\t\tif (triggerChange)\n\t\t\ttriggerEvent(\"Change\");\n\t}\n\n\tfunction setupDates() {\n\t\tfunction parseDateRules(arr) {\n\t\t\tfor (let i = arr.length; i--;) {\n\t\t\t\tif (typeof arr[i] === \"string\" || +arr[i])\n\t\t\t\t\tarr[i] = self.parseDate(arr[i], null, true);\n\n\t\t\t\telse if (arr[i] && arr[i].from && arr[i].to) {\n\t\t\t\t\tarr[i].from = self.parseDate(arr[i].from);\n\t\t\t\t\tarr[i].to = self.parseDate(arr[i].to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arr.filter(x => x); // remove falsy values\n\t\t}\n\n\t\tself.selectedDates = [];\n\t\tself.now = new Date();\n\n\t\tif (self.config.disable.length)\n\t\t\tself.config.disable = parseDateRules(self.config.disable);\n\n\t\tif (self.config.enable.length)\n\t\t\tself.config.enable = parseDateRules(self.config.enable);\n\n\t\tconst preloadedDate = self.config.defaultDate || self.input.value;\n\t\tif (preloadedDate)\n\t\t\tsetSelectedDate(preloadedDate, self.config.dateFormat);\n\n\t\tconst initialDate = (self.selectedDates.length\n\t\t\t? self.selectedDates[0]\n\t\t\t: self.config.minDate && self.config.minDate.getTime() > self.now\n\t\t\t\t? self.config.minDate\n\t\t\t\t: self.config.maxDate && self.config.maxDate.getTime() < self.now\n\t\t\t\t\t? self.config.maxDate\n\t\t\t\t\t: self.now\n\t\t);\n\n\t\tself.currentYear = initialDate.getFullYear();\n\t\tself.currentMonth = initialDate.getMonth();\n\n\t\tif (self.selectedDates.length)\n\t\t\tself.latestSelectedDateObj = self.selectedDates[0];\n\n\t\tself.minDateHasTime = self.config.minDate && (self.config.minDate.getHours()\n\t\t\t|| self.config.minDate.getMinutes()\n\t\t\t|| self.config.minDate.getSeconds());\n\n\t\tself.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours()\n\t\t\t|| self.config.maxDate.getMinutes()\n\t\t\t|| self.config.maxDate.getSeconds());\n\n\t\tObject.defineProperty(self, \"latestSelectedDateObj\", {\n\t\t\tget() {\n\t\t\t\treturn self._selectedDateObj\n\t\t\t\t\t|| self.selectedDates[self.selectedDates.length - 1];\n\t\t\t},\n\t\t\tset(date) {\n\t\t\t\tself._selectedDateObj = date;\n\t\t\t}\n\t\t});\n\n\t\tif (!self.isMobile) {\n\t\t\tObject.defineProperty(self, \"showTimeInput\", {\n\t\t\t\tget () {\n\t\t\t\t\treturn self._showTimeInput;\n\t\t\t\t},\n\t\t\t\tset (bool) {\n\t\t\t\t\tself._showTimeInput = bool;\n\t\t\t\t\tif (self.calendarContainer)\n\t\t\t\t\t\ttoggleClass(self.calendarContainer, \"showTimeInput\", bool);\n\t\t\t\t\tpositionCalendar();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setupHelperFunctions() {\n\t\tself.utils = {\n\t\t\tduration: {\n\t\t\t\tDAY: 86400000,\n\t\t\t},\n\t\t\tgetDaysinMonth (month, yr) {\n\t\t\t\tmonth = typeof month === \"undefined\"\n\t\t\t\t\t? self.currentMonth\n\t\t\t\t\t: month;\n\n\t\t\t\tyr = typeof yr === \"undefined\"\n\t\t\t\t\t? self.currentYear\n\t\t\t\t\t: yr;\n\n\t\t\t\tif (month === 1 && (((yr % 4 === 0) && (yr % 100 !== 0)) || (yr % 400 === 0)))\n\t\t\t\t\treturn 29;\n\n\t\t\t\treturn self.l10n.daysInMonth[month];\n\t\t\t},\n\n\t\t\tmonthToStr (monthNumber, shorthand) {\n\t\t\t\tshorthand = typeof shorthand === \"undefined\"\n\t\t\t\t\t? self.config.shorthandCurrentMonth\n\t\t\t\t\t: shorthand;\n\n\t\t\t\treturn self.l10n.months[(`${shorthand ? \"short\" : \"long\"}hand`)][monthNumber];\n\t\t\t}\n\t\t};\n\t}\n\n\t/* istanbul ignore next */\n\tfunction setupFormats() {\n\t\t[\"D\", \"F\", \"J\", \"M\", \"W\", \"l\"].forEach(f => {\n\t\t\tself.formats[f] = Flatpickr.prototype.formats[f].bind(self);\n\t\t});\n\n\t\tself.revFormat.F = Flatpickr.prototype.revFormat.F.bind(self);\n\t\tself.revFormat.M = Flatpickr.prototype.revFormat.M.bind(self);\n\t}\n\n\tfunction setupInputs() {\n\t\tself.input = self.config.wrap\n\t\t\t? self.element.querySelector(\"[data-input]\")\n\t\t\t: self.element;\n\n\t\t/* istanbul ignore next */\n\t\tif (!self.input)\n\t\t\treturn console.warn(\"Error: invalid input element specified\", self.input);\n\n\t\tself.input._type = self.input.type;\n\t\tself.input.type = \"text\";\n\n\t\tself.input.classList.add(\"flatpickr-input\");\n\t\tself._input = self.input;\n\n\t\tif (self.config.altInput) {\n\t\t\t// replicate self.element\n\t\t\tself.altInput = createElement(\n\t\t\t\tself.input.nodeName,\n\t\t\t\tself.input.className + \" \" + self.config.altInputClass\n\t\t\t);\n\t\t\tself._input = self.altInput;\n\t\t\tself.altInput.placeholder = self.input.placeholder;\n\t\t\tself.altInput.type = \"text\";\n\t\t\tself.input.type = \"hidden\";\n\n\t\t\tif (!self.config.static && self.input.parentNode)\n\t\t\t\tself.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);\n\t\t}\n\n\t\tif (!self.config.allowInput)\n\t\t\tself._input.setAttribute(\"readonly\", \"readonly\");\n\t}\n\n\tfunction setupMobile() {\n\t\tconst inputType = self.config.enableTime\n\t\t\t? (self.config.noCalendar ? \"time\" : \"datetime-local\")\n\t\t\t: \"date\";\n\n\t\tself.mobileInput = createElement(\"input\", self.input.className + \" flatpickr-mobile\");\n\t\tself.mobileInput.step = \"any\";\n\t\tself.mobileInput.tabIndex = 1;\n\t\tself.mobileInput.type = inputType;\n\t\tself.mobileInput.disabled = self.input.disabled;\n\t\tself.mobileInput.placeholder = self.input.placeholder;\n\n\t\tself.mobileFormatStr = inputType === \"datetime-local\"\n\t\t\t? \"Y-m-d\\\\TH:i:S\"\n\t\t\t: inputType === \"date\"\n\t\t\t\t? \"Y-m-d\"\n\t\t\t\t: \"H:i:S\";\n\n\t\tif (self.selectedDates.length) {\n\t\t\tself.mobileInput.defaultValue\n\t\t\t= self.mobileInput.value\n\t\t\t= self.formatDate(self.selectedDates[0], self.mobileFormatStr);\n\t\t}\n\n\t\tif (self.config.minDate)\n\t\t\tself.mobileInput.min = self.formatDate(self.config.minDate, \"Y-m-d\");\n\n\t\tif (self.config.maxDate)\n\t\t\tself.mobileInput.max = self.formatDate(self.config.maxDate, \"Y-m-d\");\n\n\t\tself.input.type = \"hidden\";\n\t\tif (self.config.altInput)\n\t\t\tself.altInput.type = \"hidden\";\n\n\t\ttry {\n\t\t\tself.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);\n\t\t}\n\t\tcatch (e) {\n\t\t\t//\n\t\t}\n\n\t\tself.mobileInput.addEventListener(\"change\", e => {\n\t\t\tself.setDate(e.target.value, false, self.mobileFormatStr);\n\t\t\ttriggerEvent(\"Change\");\n\t\t\ttriggerEvent(\"Close\");\n\t\t});\n\t}\n\n\tfunction toggle() {\n\t\tif (self.isOpen)\n\t\t\treturn self.close();\n\t\tself.open();\n\t}\n\n\tfunction triggerEvent(event, data) {\n\t\tconst hooks = self.config[\"on\" + event];\n\n\t\tif (hooks) {\n\t\t\tfor (let i = 0; hooks[i] && i < hooks.length; i++)\n\t\t\t\thooks[i](self.selectedDates, self.input && self.input.value, self, data);\n\t\t}\n\n\t\tif (event === \"Change\") {\n\t\t\tself.input.dispatchEvent(createEvent(\"change\"));\n\n\t\t\t// many front-end frameworks bind to the input event\n\t\t\tself.input.dispatchEvent(createEvent(\"input\"));\n\t\t}\n\t}\n\n\t/**\n\t * Creates an Event, normalized across browsers\n\t * @param {String} name the event name, e.g. \"click\"\n\t * @return {Event} the created event\n\t */\n\tfunction createEvent(name) {\n\t\tconst existing = self._[`${name}Event`];\n\t\tif (existing !== undefined)\n\t\t\treturn existing;\n\n\t\tif (self._supportsEvents)\n\t\t\treturn self._[`${name}Event`] = new Event(name, { bubbles: true });\n\n\t\tself._[`${name}Event`] = document.createEvent(\"Event\");\n\t\tself._[`${name}Event`].initEvent(name, true, true);\n\t\treturn self._[`${name}Event`];\n\t}\n\n\tfunction isDateSelected(date) {\n\t\tfor (let i = 0; i < self.selectedDates.length; i++) {\n\t\t\tif (compareDates(self.selectedDates[i], date) === 0)\n\t\t\t\treturn \"\" + i;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction isDateInRange(date){\n\t\tif (self.config.mode !== \"range\" || self.selectedDates.length < 2)\n\t\t\treturn false;\n\t\treturn compareDates(date,self.selectedDates[0]) >= 0\n\t\t\t&& compareDates(date,self.selectedDates[1]) <= 0;\n\t}\n\n\tfunction updateNavigationCurrentMonth() {\n\t\tif (self.config.noCalendar || self.isMobile || !self.monthNav)\n\t\t\treturn;\n\n\t\tself.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + \" \";\n\t\tself.currentYearElement.value = self.currentYear;\n\n\t\tself._hidePrevMonthArrow = self.config.minDate &&\n\t\t\t\t(self.currentYear === self.config.minDate.getFullYear()\n\t\t\t\t\t? self.currentMonth <= self.config.minDate.getMonth()\n\t\t\t\t\t: self.currentYear < self.config.minDate.getFullYear());\n\n\t\tself._hideNextMonthArrow = self.config.maxDate &&\n\t\t\t(self.currentYear === self.config.maxDate.getFullYear()\n\t\t\t\t? self.currentMonth + 1 > self.config.maxDate.getMonth()\n\t\t\t\t: self.currentYear > self.config.maxDate.getFullYear());\n\t}\n\n\t/**\n\t * Updates the values of inputs associated with the calendar\n\t * @return {void}\n\t */\n\tfunction updateValue() {\n\t\tif (!self.selectedDates.length)\n\t\t\treturn self.clear();\n\n\t\tif (self.isMobile) {\n\t\t\tself.mobileInput.value = self.selectedDates.length\n\t\t\t\t? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)\n\t\t\t\t: \"\";\n\t\t}\n\n\t\tconst joinChar = self.config.mode !== \"range\" ? \"; \" : self.l10n.rangeSeparator;\n\n\t\tself.input.value = self.selectedDates\n\t\t\t.map(dObj => self.formatDate(dObj, self.config.dateFormat))\n\t\t\t.join(joinChar);\n\n\t\tif (self.config.altInput) {\n\t\t\tself.altInput.value = self.selectedDates\n\t\t\t\t.map(dObj => self.formatDate(dObj, self.config.altFormat))\n\t\t\t\t.join(joinChar);\n\t\t}\n\n\t\ttriggerEvent(\"ValueUpdate\");\n\t}\n\n\tfunction mouseDelta(e) {\n\t\treturn Math.max(-1, Math.min(1, (e.wheelDelta || -e.deltaY)));\n\t}\n\n\tfunction onMonthNavScroll(e) {\n\t\te.preventDefault();\n\t\tconst isYear = self.currentYearElement.parentNode.contains(e.target);\n\n\t\tif (e.target === self.currentMonthElement || isYear) {\n\n\t\t\tconst delta = mouseDelta(e);\n\n\t\t\tif (isYear) {\n\t\t\t\tchangeYear(self.currentYear + delta);\n\t\t\t\te.target.value = self.currentYear;\n\t\t\t}\n\t\t\telse\n\t\t\t\tself.changeMonth(delta, true, false);\n\t\t}\n\t}\n\n\tfunction onMonthNavClick(e) {\n\t\tif (e.target.className === \"arrowUp\")\n\t\t\tself.changeYear(self.currentYear + 1);\n\n\t\telse if (e.target.className === \"arrowDown\")\n\t\t\tself.changeYear(self.currentYear - 1);\n\t}\n\n\t/**\n\t * Creates an HTMLElement with given tag, class, and textual content\n\t * @param {String} tag the HTML tag\n\t * @param {String} className the new element's class name\n\t * @param {String} content The new element's text content\n\t * @return {HTMLElement} the created HTML element\n\t */\n\tfunction createElement(tag, className, content) {\n\t\tconst e = window.document.createElement(tag);\n\t\tclassName = className || \"\";\n\t\tcontent = content || \"\";\n\n\t\te.className = className;\n\n\t\tif (content !== undefined)\n\t\t\te.textContent = content;\n\n\t\treturn e;\n\t}\n\n\tfunction arrayify(obj) {\n\t\tif (obj instanceof Array)\n\t\t\treturn obj;\n\t\treturn [obj];\n\t}\n\n\tfunction toggleClass(elem, className, bool) {\n\t\tif (bool)\n\t\t\treturn elem.classList.add(className);\n\t\telem.classList.remove(className);\n\t}\n\n\t/* istanbul ignore next */\n\tfunction debounce(func, wait, immediate) {\n\t\tlet timeout;\n\t\treturn function() {\n\t\t\tlet context = this, args = arguments;\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(function() {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t}, wait);\n\t\t\tif (immediate && !timeout) func.apply(context, args);\n\t\t};\n\t}\n\n\t/**\n\t * Compute the difference in dates, measured in ms\n\t * @param {Date} date1\n\t * @param {Date} date2\n\t * @param {Boolean} timeless whether to reset times of both dates to 00:00\n\t * @return {Number} the difference in ms\n\t */\n\tfunction compareDates(date1, date2, timeless) {\n\t\tif (!(date1 instanceof Date) || !(date2 instanceof Date))\n\t\t\treturn false;\n\n\t\tif (timeless !== false) {\n\t\t\treturn new Date(date1.getTime()).setHours(0,0,0,0)\n\t\t\t\t- new Date(date2.getTime()).setHours(0,0,0,0);\n\t\t}\n\n\t\treturn date1.getTime() - date2.getTime();\n\t}\n\n\tfunction timeWrapper(e) {\n\t\te.preventDefault();\n\n\t\tconst isKeyDown = e.type === \"keydown\",\n\t\t\tisWheel = e.type === \"wheel\",\n\t\t\tisIncrement = e.type === \"increment\",\n\t\t\tinput = e.target;\n\n\t\tif (self.amPM && e.target === self.amPM)\n\t\t\treturn e.target.textContent = [\"AM\", \"PM\"][(e.target.textContent === \"AM\") | 0];\n\n\t\tconst min = Number(input.min),\n\t\t\tmax = Number(input.max),\n\t\t\tstep = Number(input.step),\n\t\t\tcurValue = parseInt(input.value, 10),\n\t\t\tdelta = e.delta || (!isKeyDown\n\t\t\t\t? Math.max(-1, Math.min(1, (e.wheelDelta || -e.deltaY))) || 0\n\t\t\t\t: e.which === 38 ? 1 : -1);\n\n\t\tlet newValue = curValue + step * delta;\n\n\t\tif (typeof(input.value) !== \"undefined\" && input.value.length === 2) {\n\t\t\tconst isHourElem = input === self.hourElement,\n\t\t\t\tisMinuteElem = input === self.minuteElement;\n\n\t\t\tif (newValue < min) {\n\t\t\t\tnewValue = max + newValue + !isHourElem\n\t\t\t\t\t+ (isHourElem && !self.amPM);\n\n\t\t\t\tif (isMinuteElem)\n\t\t\t\t\tincrementNumInput(null, -1, self.hourElement)\n\t\t\t}\n\n\t\t\telse if (newValue > max) {\n\t\t\t\tnewValue = input === self.hourElement\n\t\t\t\t\t? newValue - max - (!self.amPM)\n\t\t\t\t\t: min;\n\n\t\t\t\tif (isMinuteElem)\n\t\t\t\t\tincrementNumInput(null, 1, self.hourElement);\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tself.amPM && isHourElem && (step === 1\n\t\t\t\t\t? newValue + curValue === 23\n\t\t\t\t\t: Math.abs(newValue - curValue) > step)\n\t\t\t)\n\t\t\t\tself.amPM.textContent = self.amPM.textContent === \"PM\" ? \"AM\" : \"PM\";\n\n\n\t\t\tinput.value = self.pad(newValue);\n\t\t}\n\t}\n\n\tinit();\n\treturn self;\n}\n\n/* istanbul ignore next */\nFlatpickr.defaultConfig = {\n\tmode: \"single\",\n\n\tposition: \"auto\",\n\n\tanimate: window.navigator.userAgent.indexOf(\"MSIE\") === -1,\n\n\t/* if true, dates will be parsed, formatted, and displayed in UTC.\n\tpreloading date strings w/ timezones is recommended but not necessary */\n\tutc: false,\n\n\t// wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements\n\twrap: false,\n\n\t// enables week numbers\n\tweekNumbers: false,\n\n\t// allow manual datetime input\n\tallowInput: false,\n\n\t/*\n\t\tclicking on input opens the date(time)picker.\n\t\tdisable if you wish to open the calendar manually with .open()\n\t*/\n\tclickOpens: true,\n\n\t// display time picker in 24 hour mode\n\ttime_24hr: false,\n\n\t// enables the time picker functionality\n\tenableTime: false,\n\n\t// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime\n\tnoCalendar: false,\n\n\t// more date format chars at https://chmln.github.io/flatpickr/#dateformat\n\tdateFormat: \"Y-m-d\",\n\n\t// altInput - see https://chmln.github.io/flatpickr/#altinput\n\taltInput: false,\n\n\t// the created altInput element will have this class.\n\taltInputClass: \"flatpickr-input form-control input\",\n\n\t// same as dateFormat, but for altInput\n\taltFormat: \"F j, Y\", // defaults to e.g. June 10, 2016\n\n\t// defaultDate - either a datestring or a date object. used for datetimepicker\"s initial value\n\tdefaultDate: null,\n\n\t// the minimum date that user can pick (inclusive)\n\tminDate: null,\n\n\t// the maximum date that user can pick (inclusive)\n\tmaxDate: null,\n\n\t// dateparser that transforms a given string to a date object\n\tparseDate: null,\n\n\t// dateformatter that transforms a given date object to a string, according to passed format\n\tformatDate: null,\n\n\tgetWeek (givenDate) {\n\t\tconst date = new Date(givenDate.getTime());\n\t\tconst onejan = new Date(date.getFullYear(), 0, 1);\n\t\treturn Math.ceil((((date - onejan) / 86400000) + onejan.getDay() + 1) / 7);\n\t},\n\n\t// see https://chmln.github.io/flatpickr/#disable\n\tenable: [],\n\n\t// see https://chmln.github.io/flatpickr/#disable\n\tdisable: [],\n\n\t// display the short version of month names - e.g. Sep instead of September\n\tshorthandCurrentMonth: false,\n\n\t// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar\n\tinline: false,\n\n\t// position calendar inside wrapper and next to the input element\n\t// leave at false unless you know what you\"re doing\n\t\"static\": false,\n\n\t// DOM node to append the calendar to in *static* mode\n\tappendTo: null,\n\n\t// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome\n\tprevArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>\",\n\tnextArrow: \"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>\",\n\n\t// enables seconds in the time picker\n\tenableSeconds: false,\n\n\t// step size used when scrolling/incrementing the hour element\n\thourIncrement: 1,\n\n\t// step size used when scrolling/incrementing the minute element\n\tminuteIncrement: 5,\n\n\t// initial value in the hour element\n\tdefaultHour: 12,\n\n\t// initial value in the minute element\n\tdefaultMinute: 0,\n\n\t// disable native mobile datetime input support\n\tdisableMobile: false,\n\n\t// default locale\n\tlocale: \"default\",\n\n\tplugins: [],\n\n\t// called every time calendar is closed\n\tonClose: [], // function (dateObj, dateStr) {}\n\n\t// onChange callback when user selects a date or time\n\tonChange: [], // function (dateObj, dateStr) {}\n\n\t// called for every day element\n\tonDayCreate: [],\n\n\t// called every time the month is changed\n\tonMonthChange: [],\n\n\t// called every time calendar is opened\n\tonOpen: [], // function (dateObj, dateStr) {}\n\n\t// called after the configuration has been parsed\n\tonParseConfig: [],\n\n\t// called after calendar is ready\n\tonReady: [], // function (dateObj, dateStr) {}\n\n\t// called after input value updated\n\tonValueUpdate: [],\n\n\t// called every time the year is changed\n\tonYearChange: [],\n\n\tonKeyDown: []\n};\n\n/* istanbul ignore next */\nFlatpickr.l10ns = {\n\ten: {\n\t\tweekdays: {\n\t\t\tshorthand: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n\t\t\tlonghand: [\n\t\t\t\t\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\t\t\t\t\"Thursday\", \"Friday\", \"Saturday\"\n\t\t\t]\n\t\t},\n\t\tmonths: {\n\t\t\tshorthand: [\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\",\n\t\t\t\t\"May\", \"Jun\", \"Jul\", \"Aug\",\n\t\t\t\t\"Sep\", \"Oct\", \"Nov\", \"Dec\"\n\t\t\t],\n\t\t\tlonghand: [\n\t\t\t\t\"January\", \"February\", \"March\",\t\"April\",\n\t\t\t\t\"May\", \"June\", \"July\", \"August\",\n\t\t\t\t\"September\", \"October\", \"November\", \"December\"\n\t\t\t]\n\t\t},\n\t\tdaysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n\t\tfirstDayOfWeek: 0,\n\t\tordinal: (nth) => {\n\t\t\tconst s = nth % 100;\n\t\t\tif (s > 3 && s < 21) return \"th\";\n\t\t\tswitch (s % 10) {\n\t\t\t\tcase 1: return \"st\";\n\t\t\t\tcase 2: return \"nd\";\n\t\t\t\tcase 3: return \"rd\";\n\t\t\t\tdefault: return \"th\";\n\t\t\t}\n\t\t},\n\t\trangeSeparator: \" to \",\n\t\tweekAbbreviation: \"Wk\",\n\t\tscrollTitle: \"Scroll to increment\",\n\t\ttoggleTitle: \"Click to toggle\"\n\t}\n};\n\nFlatpickr.l10ns.default = Object.create(Flatpickr.l10ns.en);\nFlatpickr.localize = l10n => Object.assign(Flatpickr.l10ns.default, l10n || {});\nFlatpickr.setDefaults = config => Object.assign(Flatpickr.defaultConfig, config || {});\n\nFlatpickr.prototype = {\n\tformats: {\n\t\t// get the date in UTC\n\t\tZ: date => date.toISOString(),\n\n\t\t// weekday name, short, e.g. Thu\n\t\tD: function (date) {\n\t\t\treturn this.l10n.weekdays.shorthand[this.formats.w(date)];\n\t\t},\n\n\t\t// full month name e.g. January\n\t\tF: function (date) {\n\t\t\treturn this.utils.monthToStr(this.formats.n(date) - 1, false);\n\t\t},\n\n\t\t// hours with leading zero e.g. 03\n\t\tH: date => Flatpickr.prototype.pad(date.getHours()),\n\n\t\t// day (1-30) with ordinal suffix e.g. 1st, 2nd\n\t\tJ: function (date) {\n\t\t\treturn date.getDate() + this.l10n.ordinal(date.getDate())\n\t\t},\n\n\t\t// AM/PM\n\t\tK: date => date.getHours() > 11 ? \"PM\" : \"AM\",\n\n\t\t// shorthand month e.g. Jan, Sep, Oct, etc\n\t\tM: function (date) {\n\t\t\treturn this.utils.monthToStr(date.getMonth(), true);\n\t\t},\n\n\t\t// seconds 00-59\n\t\tS: date => Flatpickr.prototype.pad(date.getSeconds()),\n\n\t\t// unix timestamp\n\t\tU: date => date.getTime() / 1000,\n\n\t\tW: function(date) {\n\t\t\treturn this.config.getWeek(date);\n\t\t},\n\n\t\t// full year e.g. 2016\n\t\tY: date => date.getFullYear(),\n\n\t\t// day in month, padded (01-30)\n\t\td: date => Flatpickr.prototype.pad(date.getDate()),\n\n\t\t// hour from 1-12 (am/pm)\n\t\th: date => date.getHours() % 12 ? date.getHours() % 12 : 12,\n\n\t\t// minutes, padded with leading zero e.g. 09\n\t\ti: date => Flatpickr.prototype.pad(date.getMinutes()),\n\n\t\t// day in month (1-30)\n\t\tj: date => date.getDate(),\n\n\t\t// weekday name, full, e.g. Thursday\n\t\tl: function (date) {\n\t\t\treturn this.l10n.weekdays.longhand[date.getDay()];\n\t\t},\n\n\t\t// padded month number (01-12)\n\t\tm: date => Flatpickr.prototype.pad(date.getMonth() + 1),\n\n\t\t// the month number (1-12)\n\t\tn: date => date.getMonth() + 1,\n\n\t\t// seconds 0-59\n\t\ts: date => date.getSeconds(),\n\n\t\t// number of the day of the week\n\t\tw: date => date.getDay(),\n\n\t\t// last two digits of year e.g. 16 for 2016\n\t\ty: date => String(date.getFullYear()).substring(2)\n\t},\n\n\t/**\n\t * Formats a given Date object into a string based on supplied format\n\t * @param {Date} dateObj the date object\n\t * @param {String} frmt a string composed of formatting tokens e.g. \"Y-m-d\"\n\t * @return {String} The textual representation of the date e.g. 2017-02-03\n\t */\n\tformatDate (dateObj, frmt) {\n\t\tif (this.config !== undefined && this.config.formatDate !== undefined)\n\t\t\treturn this.config.formatDate(dateObj, frmt);\n\n\t\treturn frmt.split(\"\").map((c, i, arr) => this.formats[c] && arr[i - 1] !== \"\\\\\"\n\t\t\t? this.formats[c](dateObj)\n\t\t\t: c !== \"\\\\\" ? c : \"\"\n\t\t).join(\"\");\n\t},\n\n\trevFormat: {\n\t\tD: () => {},\n\t\tF: function(dateObj, monthName) {\n\t\t\tdateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));\n\t\t},\n\t\tH: (dateObj, hour) => {\n\t\t\tdateObj.setHours(parseFloat(hour))\n\t\t},\n\t\tJ: (dateObj, day) => {\n\t\t\tdateObj.setDate(parseFloat(day))\n\t\t},\n\t\tK: (dateObj, amPM) => {\n\t\t\tconst hours = dateObj.getHours();\n\n\t\t\tif (hours !== 12)\n\t\t\t\tdateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));\n\t\t},\n\t\tM: function(dateObj, shortMonth) {\n\t\t\tdateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));\n\t\t},\n\t\tS: (dateObj, seconds) => {\n\t\t\tdateObj.setSeconds(seconds);\n\t\t},\n\t\tU: (dateObj, unixSeconds) => new Date(parseFloat(unixSeconds) * 1000),\n\n\t\tW: function(dateObj, weekNumber){\n\t\t\tweekNumber = parseInt(weekNumber);\n\t\t\treturn new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);\n\t\t},\n\t\tY: (dateObj, year) =>  {\n\t\t\tdateObj.setFullYear(year);\n\t\t},\n\t\tZ: (dateObj, ISODate) => new Date(ISODate),\n\n\t\td: (dateObj, day) =>  {\n\t\t\tdateObj.setDate(parseFloat(day))\n\t\t},\n\t\th: (dateObj, hour) =>  {\n\t\t\tdateObj.setHours(parseFloat(hour))\n\t\t},\n\t\ti: (dateObj, minutes) =>  {\n\t\t\tdateObj.setMinutes(parseFloat(minutes))\n\t\t},\n\t\tj: (dateObj, day) =>  {\n\t\t\tdateObj.setDate(parseFloat(day))\n\t\t},\n\t\tl: () =>  {},\n\t\tm: (dateObj, month) =>  {\n\t\t\tdateObj.setMonth(parseFloat(month) - 1)\n\t\t},\n\t\tn: (dateObj, month) =>  {\n\t\t\tdateObj.setMonth(parseFloat(month) - 1)\n\t\t},\n\t\ts: (dateObj, seconds) =>  {\n\t\t\tdateObj.setSeconds(parseFloat(seconds))\n\t\t},\n\t\tw: () =>  {},\n\t\ty: (dateObj, year) =>  {\n\t\t\tdateObj.setFullYear(2000 + parseFloat(year))\n\t\t},\n\t},\n\n\ttokenRegex: {\n\t\tD:\"(\\\\w+)\",\n\t\tF:\"(\\\\w+)\",\n\t\tH:\"(\\\\d\\\\d|\\\\d)\",\n\t\tJ:\"(\\\\d\\\\d|\\\\d)\\\\w+\",\n\t\tK:\"(\\\\w+)\",\n\t\tM:\"(\\\\w+)\",\n\t\tS:\"(\\\\d\\\\d|\\\\d)\",\n\t\tU: \"(.+)\",\n\t\tW:\"(\\\\d\\\\d|\\\\d)\",\n\t\tY:\"(\\\\d{4})\",\n\t\tZ:\"(.+)\",\n\t\td:\"(\\\\d\\\\d|\\\\d)\",\n\t\th:\"(\\\\d\\\\d|\\\\d)\",\n\t\ti:\"(\\\\d\\\\d|\\\\d)\",\n\t\tj:\"(\\\\d\\\\d|\\\\d)\",\n\t\tl:\"(\\\\w+)\",\n\t\tm:\"(\\\\d\\\\d|\\\\d)\",\n\t\tn:\"(\\\\d\\\\d|\\\\d)\",\n\t\ts:\"(\\\\d\\\\d|\\\\d)\",\n\t\tw: \"(\\\\d\\\\d|\\\\d)\",\n\t\ty:\"(\\\\d{2})\"\n\t},\n\n\tpad: number => `0${number}`.slice(-2),\n\n\t/**\n\t * Parses a date(+time) string into a Date object\n\t * @param {String} date the date string, e.g. 2017-02-03 14:45\n\t * @param {String} givenFormat the date format, e.g. Y-m-d H:i\n\t * @param {Boolean} timeless whether to reset the time of Date object\n\t * @return {Date} the parsed Date object\n\t */\n\tparseDate (date, givenFormat, timeless) {\n\t\tif (!date)\n\t\t\treturn null;\n\n\t\tconst date_orig = date;\n\n\t\tif (date instanceof Date)\n\t\t\tdate = new Date(date.getTime()); // create a copy\n\n\t\telse if (date.toFixed !== undefined) // timestamp\n\t\t\tdate = new Date(date);\n\n\t\telse { // date string\n\t\t\tconst format = givenFormat || (this.config || Flatpickr.defaultConfig).dateFormat;\n\t\t\tdate = String(date).trim();\n\n\t\t\tif (date === \"today\") {\n\t\t\t\tdate = new Date();\n\t\t\t\ttimeless = true;\n\t\t\t}\n\n\t\t\telse if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone\n\t\t\t\tdate = new Date(date);\n\n\t\t\telse if (this.config && this.config.parseDate)\n\t\t\t\tdate = this.config.parseDate(date, format);\n\n\t\t\telse {\n\t\t\t\tlet parsedDate = !this.config || !this.config.noCalendar\n\t\t\t\t\t? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0 ,0)\n\t\t\t\t\t: new Date(new Date().setHours(0,0,0,0));\n\n\t\t\t\tlet matched;\n\n\t\t\t\tfor (let i = 0, matchIndex = 0, regexStr = \"\"; i < format.length; i++) {\n\t\t\t\t\tconst token = format[i];\n\t\t\t\t\tconst isBackSlash = token === \"\\\\\";\n\t\t\t\t\tconst escaped = format[i - 1] === \"\\\\\" || isBackSlash;\n\n\t\t\t\t\tif (this.tokenRegex[token] && !escaped) {\n\t\t\t\t\t\tregexStr += this.tokenRegex[token];\n\t\t\t\t\t\tconst match = new RegExp(regexStr).exec(date);\n\t\t\t\t\t\tif (match && (matched = true)) {\n\t\t\t\t\t\t\tparsedDate =\n\t\t\t\t\t\t\t\tthis.revFormat[token](parsedDate, match[++matchIndex])\n\t\t\t\t\t\t\t\t|| parsedDate;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (!isBackSlash)\n\t\t\t\t\t\tregexStr += \".\"; // don't really care\n\n\t\t\t\t}\n\n\t\t\t\tdate = matched\t? parsedDate : null;\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore next */\n\t\tif (!(date instanceof Date)) {\n\t\t\tconsole.warn(`flatpickr: invalid date ${date_orig}`);\n\t\t\tconsole.info(this.element);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (this.config && this.config.utc && !date.fp_isUTC)\n\t\t\tdate = date.fp_toUTC();\n\n\t\tif (timeless === true)\n\t\t\tdate.setHours(0, 0, 0, 0);\n\n\t\treturn date;\n\t}\n};\n\n/* istanbul ignore next */\nfunction _flatpickr(nodeList, config) {\n\tconst nodes = Array.prototype.slice.call(nodeList); // static list\n\tlet instances = [];\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\ttry {\n\t\t\tnodes[i]._flatpickr = new Flatpickr(nodes[i], config || {});\n\t\t\tinstances.push(nodes[i]._flatpickr);\n\t\t}\n\n\t\tcatch (e) {\n\t\t\tconsole.warn(e, e.stack);\n\t\t}\n\t}\n\n\treturn instances.length === 1 ? instances[0] : instances;\n}\n\n/* istanbul ignore next */\nif (typeof HTMLElement !== \"undefined\") { // browser env\n\tHTMLCollection.prototype.flatpickr =\n\tNodeList.prototype.flatpickr = function (config) {\n\t\treturn _flatpickr(this, config);\n\t};\n\n\tHTMLElement.prototype.flatpickr = function (config) {\n\t\treturn _flatpickr([this], config);\n\t};\n}\n\n/* istanbul ignore next */\nfunction flatpickr(selector, config) {\n\treturn _flatpickr(window.document.querySelectorAll(selector), config);\n}\n\n/* istanbul ignore next */\nif (typeof jQuery !== \"undefined\") {\n\tjQuery.fn.flatpickr = function (config) {\n\t\treturn _flatpickr(this, config);\n\t};\n}\n\nDate.prototype.fp_incr = function (days) {\n\treturn new Date(\n\t\tthis.getFullYear(),\n\t\tthis.getMonth(),\n\t\tthis.getDate() + parseInt(days, 10)\n\t);\n};\n\nDate.prototype.fp_isUTC = false;\nDate.prototype.fp_toUTC = function () {\n\tconst newDate = new Date(\n\t\tthis.getUTCFullYear(),\n\t\tthis.getUTCMonth(),\n\t\tthis.getUTCDate(),\n\t\tthis.getUTCHours(),\n\t\tthis.getUTCMinutes(),\n\t\tthis.getUTCSeconds()\n\t);\n\n\tnewDate.fp_isUTC = true;\n\treturn newDate;\n};\n\nif (typeof module !== \"undefined\")\n\tmodule.exports = Flatpickr;\n"}